list of level 1 subjects
  - Nix
  - Nix ğŸ”ªâ­• Home Manager
  - Nix ğŸ”ªâ­• Flake
  

â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»  
âš“â­• Nix ; https://pixi.sh/latest/
  https://github.com/prefix-dev/pixi?tab=readme-ov-file
  Nix is a cross-platform, multi-language package manager and workflow tool built on the foundation of the conda ecosystem.


----------------------------------------------
Nix ğŸ”ªâš“ Download ; https://nixos.org/download/
  â­• Multi-user installation (recommended)
    Install Nix via the recommended multi-user installation:
      $ sh <(curl -L https://nixos.org/nix/install) --daemon
    We recommend the multi-user install if you are on Linux running systemd, with SELinux disabled and you can authenticate with sudo.


----------------------------------------------
Nix ğŸ”ªâš“ğŸ–‡ï¸ How Nix Works ; https://nixos.org/guides/how-nix-works/ ğŸ“… 2024-08-31 16:25:29
  ğŸ’¡ Not using â€˜globalâ€™ directories such as /bin is what allows multiple versions of a package to coexist. Nix does have a /etc to keep system-wide configuration files, but most files in that directory are symlinks to generated files in /nix/store.

  * System Management
    â””â”€ Portability
    â””â”€ Complete dependencies
      ğŸ”‘ğŸ“ ... you are supposed to declare its dependencies, but you canâ€™t easily guarantee that your dependency declaration is complete. 
        If you forget a dependency, that you have separately installed on your machine, then the component may build and work correctly on your machine, but failing on the end userâ€™s machine.

  * Upgrade and Rollback
    â””â”€ (Atomic, reliable) upgrades and rollbacks
      # contents
        ... So during a package upgrade, there is no ğŸª± time window ...
        And since packages ğŸš£ arenâ€™t overwritten, the old versions are still there after an upgrade. ğŸ“ This means that you can roll back to the old version:
        %shell> nix-env --upgrade _some-packages_
        %shell> nix-env --rollback
      
      # Atomic upgrades
        ... ğŸª± transactional .. atomic ...
        ... In most other systems, youâ€™ll end up in an inconsistent state, and your machine may not even boot anymore.
      # Rollbacks
        ğŸ‘ So if the new configuration crashes or doesnâ€™t boot properly, you can just roll back by selecting an older configuration in the boot menu.
        ğŸ‘ Rollbacks are very fast: it doesnâ€™t involve lots of files having to be restored from copies.
      # Reliable upgrades
        ğŸ“ Another advantage of purely functional package management is that nixos-rebuild switch will always produce the same result, regardless of what packages or configuration files you already had on your system.
        Thus, upgrading a system is as reliable as reinstalling from scratch.
  
  * Configuration Management
    â””â”€ Multi-user support
      Starting at version 0.11, Nix has multi-user support. This means that non-privileged users can securely install software.
      âš–ï¸ Each user can have a different profile, ...
      ğŸ“ If a user installs a package that another user has already installed previously, the package wonâ€™t be built or downloaded a second time.
      At the same time, it is not possible for one user to inject a Trojan horse into a package that might be used by another user.

    â””â”€ Safe to test changes
        This builds and activates the new configuration, but doesnâ€™t make it the boot default. Thus, rebooting the system will take you back to the previous, known-good configuration.
          %shell> nixos-rebuild test

        ğŸ“ The build-vm command is very efficient (it doesnâ€™t require a disk image for the VM to be created), so itâ€™s a very effective way to test changes.
        %shell> nixos-rebuild build-vm
        %shell> ./result/bin/run-\*-vm
    â””â”€ Declarative system configuration model
        The fact that itâ€™s purely functional essentially means that building a new configuration cannot overwrite previous configurations
        %shell> nixos-rebuild switch
    â””â”€ Reproducible system configurations
      You just copy the configuration.nix file to the target NixOS machine and run nixos-rebuild switch.
      âš ï¸ This will give you the same configuration (kernel, applications, system services, and so on) except for â€˜mutable stateâ€™ (such as the stuff that lives in /var).

  * Package Management
    â””â”€ Multiple versions
      ... ğŸ’¡ it prevents the â€œDLL hellâ€. Because of the hashing scheme
      ... since these operations never ğŸš£ â€œdestructivelyâ€ update or delete files that are used by other packages.
    â””â”€ Functional package language
      A ğŸª± Nix expression describes everything that goes into a package build action (a â€œderivationâ€): other packages, sources, the build script, environment variables for the build script, etc.
      Nix tries very hard to ensure that Nix expressions are ğŸª± deterministic

    â””â”€ Transparent source/binary deployment
      ğŸª± source deployment model
      ğŸ“âš–ï¸ For most users, building from source is not very pleasant as it takes far too long.
        However, Nix can automatically skip building from source and instead use a ğŸª± binary cache, a web server that provides pre-built binaries. 
    â””â”€ Garbage collection
      %shell> nix-env --uninstall firefox
        ğŸ”‘ the package isnâ€™t deleted from the system right away (after all, you might want to do a rollback, or it might be in the profiles of other users)
      %shell> nix-collect-garbage
        This deletes all packages that arenâ€™t in use by any user profile or by a currently running program.

    â””â”€ Nix Packages collection
      https://github.com/NixOS/nixpkgs ; ğŸª± large set of Nix expressions containing thousands of existing Unix packages

----------------------------------------------
Nix ğŸ”ªâš“ Tutorials ; https://nix.dev/tutorials/
  âš“ First steps ; https://nix.dev/tutorials/first-steps/


â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»  
âš“ Nix ğŸ”ªâ­• Home Manager ; https://github.com/nix-community/home-manager
  This project provides a basic system for managing a user environment using the Nix package manager together with the Nix libraries found in Nixpkgs.
    https://github.com/NixOS/nixpkgs
  It allows ğŸª± declarative configuration of user specific (non-global) packages and dotfiles.

  #ï¸âƒ£ğŸ”° Using Home Manager ; https://nix-community.github.io/home-manager/index.xhtml#ch-usage
    
  

  
----------------------------------------------
Home Manager ğŸ”ª#ï¸âƒ£ Installation ; https://github.com/nix-community/home-manager?tab=readme-ov-file#installation
  Home Manager can be used in three primary ways:
    â­• 1. Using the standalone home-manager tool.; https://nix-community.github.io/home-manager/#sec-install-standalone
      
      For platforms other than NixOS and Darwin, this is the only available choice.
      It is also recommended for people on NixOS or Darwin that want to manage their home directory independently of the system as a whole
  
----------------------------------------------
Home Manager ğŸ”ªâš“ Manual ; https://nix-community.github.io/home-manager/



â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»â€»  
âš“ Nix ğŸ”ªâ­• Flake ; https://github.com/nix-community/home-manager
  Flakes are the unit for packaging Nix code in a reproducible and discoverable way
  A flake is a filesystem tree (typically fetched from a Git repository or a tarball) that contains a file named flake.nix in the root directory. flake.nix specifies some metadata about the flake such as dependencies (called inputs), as well as its outputs (the Nix values such as packages or NixOS modules provided by the flake).





`