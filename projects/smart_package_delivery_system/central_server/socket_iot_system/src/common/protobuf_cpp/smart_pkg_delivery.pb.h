// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: smart_pkg_delivery.proto
// Protobuf C++ Version: 5.29.3

#ifndef smart_5fpkg_5fdelivery_2eproto_2epb_2eh
#define smart_5fpkg_5fdelivery_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_smart_5fpkg_5fdelivery_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_smart_5fpkg_5fdelivery_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_smart_5fpkg_5fdelivery_2eproto;
namespace smart_pkg_delivery {
class AckStatus;
struct AckStatusDefaultTypeInternal;
extern AckStatusDefaultTypeInternal _AckStatus_default_instance_;
class AptAddress;
struct AptAddressDefaultTypeInternal;
extern AptAddressDefaultTypeInternal _AptAddress_default_instance_;
class ClientRegisterRequest;
struct ClientRegisterRequestDefaultTypeInternal;
extern ClientRegisterRequestDefaultTypeInternal _ClientRegisterRequest_default_instance_;
class ClientRegisterResponse;
struct ClientRegisterResponseDefaultTypeInternal;
extern ClientRegisterResponseDefaultTypeInternal _ClientRegisterResponse_default_instance_;
class DeliveryRobot;
struct DeliveryRobotDefaultTypeInternal;
extern DeliveryRobotDefaultTypeInternal _DeliveryRobot_default_instance_;
class DeliveryStatusEvent;
struct DeliveryStatusEventDefaultTypeInternal;
extern DeliveryStatusEventDefaultTypeInternal _DeliveryStatusEvent_default_instance_;
class Elevator;
struct ElevatorDefaultTypeInternal;
extern ElevatorDefaultTypeInternal _Elevator_default_instance_;
class ElevatorStatusEvent;
struct ElevatorStatusEventDefaultTypeInternal;
extern ElevatorStatusEventDefaultTypeInternal _ElevatorStatusEvent_default_instance_;
class Elevator_Status;
struct Elevator_StatusDefaultTypeInternal;
extern Elevator_StatusDefaultTypeInternal _Elevator_Status_default_instance_;
class ExecutionStatus;
struct ExecutionStatusDefaultTypeInternal;
extern ExecutionStatusDefaultTypeInternal _ExecutionStatus_default_instance_;
class GetPkgInfoResponse;
struct GetPkgInfoResponseDefaultTypeInternal;
extern GetPkgInfoResponseDefaultTypeInternal _GetPkgInfoResponse_default_instance_;
class GetPkgInfosRequest;
struct GetPkgInfosRequestDefaultTypeInternal;
extern GetPkgInfosRequestDefaultTypeInternal _GetPkgInfosRequest_default_instance_;
class InteractionMsg;
struct InteractionMsgDefaultTypeInternal;
extern InteractionMsgDefaultTypeInternal _InteractionMsg_default_instance_;
class MoveDeliveryRobotRequest;
struct MoveDeliveryRobotRequestDefaultTypeInternal;
extern MoveDeliveryRobotRequestDefaultTypeInternal _MoveDeliveryRobotRequest_default_instance_;
class MoveDeliveryRobotResponse;
struct MoveDeliveryRobotResponseDefaultTypeInternal;
extern MoveDeliveryRobotResponseDefaultTypeInternal _MoveDeliveryRobotResponse_default_instance_;
class NodeEvent;
struct NodeEventDefaultTypeInternal;
extern NodeEventDefaultTypeInternal _NodeEvent_default_instance_;
class Pkg;
struct PkgDefaultTypeInternal;
extern PkgDefaultTypeInternal _Pkg_default_instance_;
class PkgArrivalEvent;
struct PkgArrivalEventDefaultTypeInternal;
extern PkgArrivalEventDefaultTypeInternal _PkgArrivalEvent_default_instance_;
class PkgRoom;
struct PkgRoomDefaultTypeInternal;
extern PkgRoomDefaultTypeInternal _PkgRoom_default_instance_;
class PkgRoom_Locker;
struct PkgRoom_LockerDefaultTypeInternal;
extern PkgRoom_LockerDefaultTypeInternal _PkgRoom_Locker_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class SetElevatorStatusRequest;
struct SetElevatorStatusRequestDefaultTypeInternal;
extern SetElevatorStatusRequestDefaultTypeInternal _SetElevatorStatusRequest_default_instance_;
class SetElevatorStatusResponse;
struct SetElevatorStatusResponseDefaultTypeInternal;
extern SetElevatorStatusResponseDefaultTypeInternal _SetElevatorStatusResponse_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace smart_pkg_delivery
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace smart_pkg_delivery {
enum AckStatus_StatusCode : int {
  AckStatus_StatusCode_UNSPECIFIED = 0,
  AckStatus_StatusCode_ACK_RECEIVED = 1,
  AckStatus_StatusCode_ACK_INVALID = 2,
  AckStatus_StatusCode_AckStatus_StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AckStatus_StatusCode_AckStatus_StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AckStatus_StatusCode_IsValid(int value);
extern const uint32_t AckStatus_StatusCode_internal_data_[];
constexpr AckStatus_StatusCode AckStatus_StatusCode_StatusCode_MIN = static_cast<AckStatus_StatusCode>(0);
constexpr AckStatus_StatusCode AckStatus_StatusCode_StatusCode_MAX = static_cast<AckStatus_StatusCode>(2);
constexpr int AckStatus_StatusCode_StatusCode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
AckStatus_StatusCode_descriptor();
template <typename T>
const std::string& AckStatus_StatusCode_Name(T value) {
  static_assert(std::is_same<T, AckStatus_StatusCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StatusCode_Name().");
  return AckStatus_StatusCode_Name(static_cast<AckStatus_StatusCode>(value));
}
template <>
inline const std::string& AckStatus_StatusCode_Name(AckStatus_StatusCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AckStatus_StatusCode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AckStatus_StatusCode_Parse(absl::string_view name, AckStatus_StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AckStatus_StatusCode>(
      AckStatus_StatusCode_descriptor(), name, value);
}
enum ExecutionStatus_StatusCode : int {
  ExecutionStatus_StatusCode_UNSPECIFIED = 0,
  ExecutionStatus_StatusCode_SUCCESS = 1,
  ExecutionStatus_StatusCode_FAILED = 2,
  ExecutionStatus_StatusCode_ExecutionStatus_StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ExecutionStatus_StatusCode_ExecutionStatus_StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ExecutionStatus_StatusCode_IsValid(int value);
extern const uint32_t ExecutionStatus_StatusCode_internal_data_[];
constexpr ExecutionStatus_StatusCode ExecutionStatus_StatusCode_StatusCode_MIN = static_cast<ExecutionStatus_StatusCode>(0);
constexpr ExecutionStatus_StatusCode ExecutionStatus_StatusCode_StatusCode_MAX = static_cast<ExecutionStatus_StatusCode>(2);
constexpr int ExecutionStatus_StatusCode_StatusCode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ExecutionStatus_StatusCode_descriptor();
template <typename T>
const std::string& ExecutionStatus_StatusCode_Name(T value) {
  static_assert(std::is_same<T, ExecutionStatus_StatusCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StatusCode_Name().");
  return ExecutionStatus_StatusCode_Name(static_cast<ExecutionStatus_StatusCode>(value));
}
template <>
inline const std::string& ExecutionStatus_StatusCode_Name(ExecutionStatus_StatusCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExecutionStatus_StatusCode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ExecutionStatus_StatusCode_Parse(absl::string_view name, ExecutionStatus_StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecutionStatus_StatusCode>(
      ExecutionStatus_StatusCode_descriptor(), name, value);
}
enum Elevator_DoorOpenStatus : int {
  Elevator_DoorOpenStatus_UNSPECIFIED = 0,
  Elevator_DoorOpenStatus_CLOSED = 1,
  Elevator_DoorOpenStatus_OPEN = 2,
  Elevator_DoorOpenStatus_Elevator_DoorOpenStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Elevator_DoorOpenStatus_Elevator_DoorOpenStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Elevator_DoorOpenStatus_IsValid(int value);
extern const uint32_t Elevator_DoorOpenStatus_internal_data_[];
constexpr Elevator_DoorOpenStatus Elevator_DoorOpenStatus_DoorOpenStatus_MIN = static_cast<Elevator_DoorOpenStatus>(0);
constexpr Elevator_DoorOpenStatus Elevator_DoorOpenStatus_DoorOpenStatus_MAX = static_cast<Elevator_DoorOpenStatus>(2);
constexpr int Elevator_DoorOpenStatus_DoorOpenStatus_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Elevator_DoorOpenStatus_descriptor();
template <typename T>
const std::string& Elevator_DoorOpenStatus_Name(T value) {
  static_assert(std::is_same<T, Elevator_DoorOpenStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DoorOpenStatus_Name().");
  return Elevator_DoorOpenStatus_Name(static_cast<Elevator_DoorOpenStatus>(value));
}
template <>
inline const std::string& Elevator_DoorOpenStatus_Name(Elevator_DoorOpenStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Elevator_DoorOpenStatus_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Elevator_DoorOpenStatus_Parse(absl::string_view name, Elevator_DoorOpenStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Elevator_DoorOpenStatus>(
      Elevator_DoorOpenStatus_descriptor(), name, value);
}
enum DeliveryRobot_DeliveryStatus : int {
  DeliveryRobot_DeliveryStatus_UNSPECIFIED = 0,
  DeliveryRobot_DeliveryStatus_PENDING = 1,
  DeliveryRobot_DeliveryStatus_IN_TRANSIT = 2,
  DeliveryRobot_DeliveryStatus_DELIVERED = 3,
  DeliveryRobot_DeliveryStatus_DeliveryRobot_DeliveryStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DeliveryRobot_DeliveryStatus_DeliveryRobot_DeliveryStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DeliveryRobot_DeliveryStatus_IsValid(int value);
extern const uint32_t DeliveryRobot_DeliveryStatus_internal_data_[];
constexpr DeliveryRobot_DeliveryStatus DeliveryRobot_DeliveryStatus_DeliveryStatus_MIN = static_cast<DeliveryRobot_DeliveryStatus>(0);
constexpr DeliveryRobot_DeliveryStatus DeliveryRobot_DeliveryStatus_DeliveryStatus_MAX = static_cast<DeliveryRobot_DeliveryStatus>(3);
constexpr int DeliveryRobot_DeliveryStatus_DeliveryStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
DeliveryRobot_DeliveryStatus_descriptor();
template <typename T>
const std::string& DeliveryRobot_DeliveryStatus_Name(T value) {
  static_assert(std::is_same<T, DeliveryRobot_DeliveryStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DeliveryStatus_Name().");
  return DeliveryRobot_DeliveryStatus_Name(static_cast<DeliveryRobot_DeliveryStatus>(value));
}
template <>
inline const std::string& DeliveryRobot_DeliveryStatus_Name(DeliveryRobot_DeliveryStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DeliveryRobot_DeliveryStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool DeliveryRobot_DeliveryStatus_Parse(absl::string_view name, DeliveryRobot_DeliveryStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeliveryRobot_DeliveryStatus>(
      DeliveryRobot_DeliveryStatus_descriptor(), name, value);
}
enum NodeType : int {
  UNSPECIFIED = 0,
  SERVER = 1,
  CLIENT_ADDRESS_RECOGNIZER = 2,
  CLIENT_USER = 3,
  CLIENT_DELIVERY_ROBOT = 4,
  CLIENT_ELEVATOR = 5,
  NodeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeType_IsValid(int value);
extern const uint32_t NodeType_internal_data_[];
constexpr NodeType NodeType_MIN = static_cast<NodeType>(0);
constexpr NodeType NodeType_MAX = static_cast<NodeType>(5);
constexpr int NodeType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
NodeType_descriptor();
template <typename T>
const std::string& NodeType_Name(T value) {
  static_assert(std::is_same<T, NodeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NodeType_Name().");
  return NodeType_Name(static_cast<NodeType>(value));
}
template <>
inline const std::string& NodeType_Name(NodeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool NodeType_Parse(absl::string_view name, NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeType>(
      NodeType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SetElevatorStatusResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.SetElevatorStatusResponse) */ {
 public:
  inline SetElevatorStatusResponse() : SetElevatorStatusResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetElevatorStatusResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetElevatorStatusResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetElevatorStatusResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetElevatorStatusResponse(const SetElevatorStatusResponse& from) : SetElevatorStatusResponse(nullptr, from) {}
  inline SetElevatorStatusResponse(SetElevatorStatusResponse&& from) noexcept
      : SetElevatorStatusResponse(nullptr, std::move(from)) {}
  inline SetElevatorStatusResponse& operator=(const SetElevatorStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetElevatorStatusResponse& operator=(SetElevatorStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetElevatorStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetElevatorStatusResponse* internal_default_instance() {
    return reinterpret_cast<const SetElevatorStatusResponse*>(
        &_SetElevatorStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SetElevatorStatusResponse& a, SetElevatorStatusResponse& b) { a.Swap(&b); }
  inline void Swap(SetElevatorStatusResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetElevatorStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetElevatorStatusResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SetElevatorStatusResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetElevatorStatusResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetElevatorStatusResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.SetElevatorStatusResponse"; }

 protected:
  explicit SetElevatorStatusResponse(::google::protobuf::Arena* arena);
  SetElevatorStatusResponse(::google::protobuf::Arena* arena, const SetElevatorStatusResponse& from);
  SetElevatorStatusResponse(::google::protobuf::Arena* arena, SetElevatorStatusResponse&& from) noexcept
      : SetElevatorStatusResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.SetElevatorStatusResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetElevatorStatusResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class PkgRoom_Locker final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.PkgRoom.Locker) */ {
 public:
  inline PkgRoom_Locker() : PkgRoom_Locker(nullptr) {}
  ~PkgRoom_Locker() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PkgRoom_Locker* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PkgRoom_Locker));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PkgRoom_Locker(
      ::google::protobuf::internal::ConstantInitialized);

  inline PkgRoom_Locker(const PkgRoom_Locker& from) : PkgRoom_Locker(nullptr, from) {}
  inline PkgRoom_Locker(PkgRoom_Locker&& from) noexcept
      : PkgRoom_Locker(nullptr, std::move(from)) {}
  inline PkgRoom_Locker& operator=(const PkgRoom_Locker& from) {
    CopyFrom(from);
    return *this;
  }
  inline PkgRoom_Locker& operator=(PkgRoom_Locker&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PkgRoom_Locker& default_instance() {
    return *internal_default_instance();
  }
  static inline const PkgRoom_Locker* internal_default_instance() {
    return reinterpret_cast<const PkgRoom_Locker*>(
        &_PkgRoom_Locker_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(PkgRoom_Locker& a, PkgRoom_Locker& b) { a.Swap(&b); }
  inline void Swap(PkgRoom_Locker* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PkgRoom_Locker* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PkgRoom_Locker* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PkgRoom_Locker>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PkgRoom_Locker& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PkgRoom_Locker& from) { PkgRoom_Locker::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PkgRoom_Locker* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.PkgRoom.Locker"; }

 protected:
  explicit PkgRoom_Locker(::google::protobuf::Arena* arena);
  PkgRoom_Locker(::google::protobuf::Arena* arena, const PkgRoom_Locker& from);
  PkgRoom_Locker(::google::protobuf::Arena* arena, PkgRoom_Locker&& from) noexcept
      : PkgRoom_Locker(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccessCodeFieldNumber = 2,
    kLockerIdFieldNumber = 1,
    kPkgIdFieldNumber = 3,
  };
  // string access_code = 2;
  bool has_access_code() const;
  void clear_access_code() ;
  const std::string& access_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_access_code(Arg_&& arg, Args_... args);
  std::string* mutable_access_code();
  PROTOBUF_NODISCARD std::string* release_access_code();
  void set_allocated_access_code(std::string* value);

  private:
  const std::string& _internal_access_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_code(
      const std::string& value);
  std::string* _internal_mutable_access_code();

  public:
  // uint32 locker_id = 1;
  bool has_locker_id() const;
  void clear_locker_id() ;
  ::uint32_t locker_id() const;
  void set_locker_id(::uint32_t value);

  private:
  ::uint32_t _internal_locker_id() const;
  void _internal_set_locker_id(::uint32_t value);

  public:
  // uint32 pkg_id = 3;
  bool has_pkg_id() const;
  void clear_pkg_id() ;
  ::uint32_t pkg_id() const;
  void set_pkg_id(::uint32_t value);

  private:
  ::uint32_t _internal_pkg_id() const;
  void _internal_set_pkg_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.PkgRoom.Locker)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      53, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PkgRoom_Locker& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr access_code_;
    ::uint32_t locker_id_;
    ::uint32_t pkg_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class MoveDeliveryRobotResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.MoveDeliveryRobotResponse) */ {
 public:
  inline MoveDeliveryRobotResponse() : MoveDeliveryRobotResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MoveDeliveryRobotResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MoveDeliveryRobotResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveDeliveryRobotResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline MoveDeliveryRobotResponse(const MoveDeliveryRobotResponse& from) : MoveDeliveryRobotResponse(nullptr, from) {}
  inline MoveDeliveryRobotResponse(MoveDeliveryRobotResponse&& from) noexcept
      : MoveDeliveryRobotResponse(nullptr, std::move(from)) {}
  inline MoveDeliveryRobotResponse& operator=(const MoveDeliveryRobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveDeliveryRobotResponse& operator=(MoveDeliveryRobotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveDeliveryRobotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveDeliveryRobotResponse* internal_default_instance() {
    return reinterpret_cast<const MoveDeliveryRobotResponse*>(
        &_MoveDeliveryRobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(MoveDeliveryRobotResponse& a, MoveDeliveryRobotResponse& b) { a.Swap(&b); }
  inline void Swap(MoveDeliveryRobotResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveDeliveryRobotResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveDeliveryRobotResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<MoveDeliveryRobotResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MoveDeliveryRobotResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MoveDeliveryRobotResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.MoveDeliveryRobotResponse"; }

 protected:
  explicit MoveDeliveryRobotResponse(::google::protobuf::Arena* arena);
  MoveDeliveryRobotResponse(::google::protobuf::Arena* arena, const MoveDeliveryRobotResponse& from);
  MoveDeliveryRobotResponse(::google::protobuf::Arena* arena, MoveDeliveryRobotResponse&& from) noexcept
      : MoveDeliveryRobotResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.MoveDeliveryRobotResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MoveDeliveryRobotResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class GetPkgInfosRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.GetPkgInfosRequest) */ {
 public:
  inline GetPkgInfosRequest() : GetPkgInfosRequest(nullptr) {}
  ~GetPkgInfosRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetPkgInfosRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetPkgInfosRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetPkgInfosRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetPkgInfosRequest(const GetPkgInfosRequest& from) : GetPkgInfosRequest(nullptr, from) {}
  inline GetPkgInfosRequest(GetPkgInfosRequest&& from) noexcept
      : GetPkgInfosRequest(nullptr, std::move(from)) {}
  inline GetPkgInfosRequest& operator=(const GetPkgInfosRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPkgInfosRequest& operator=(GetPkgInfosRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPkgInfosRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPkgInfosRequest* internal_default_instance() {
    return reinterpret_cast<const GetPkgInfosRequest*>(
        &_GetPkgInfosRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GetPkgInfosRequest& a, GetPkgInfosRequest& b) { a.Swap(&b); }
  inline void Swap(GetPkgInfosRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPkgInfosRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPkgInfosRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetPkgInfosRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPkgInfosRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetPkgInfosRequest& from) { GetPkgInfosRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetPkgInfosRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.GetPkgInfosRequest"; }

 protected:
  explicit GetPkgInfosRequest(::google::protobuf::Arena* arena);
  GetPkgInfosRequest(::google::protobuf::Arena* arena, const GetPkgInfosRequest& from);
  GetPkgInfosRequest(::google::protobuf::Arena* arena, GetPkgInfosRequest&& from) noexcept
      : GetPkgInfosRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
  };
  // uint32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id() ;
  ::uint32_t user_id() const;
  void set_user_id(::uint32_t value);

  private:
  ::uint32_t _internal_user_id() const;
  void _internal_set_user_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.GetPkgInfosRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetPkgInfosRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t user_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class ExecutionStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.ExecutionStatus) */ {
 public:
  inline ExecutionStatus() : ExecutionStatus(nullptr) {}
  ~ExecutionStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExecutionStatus* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExecutionStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExecutionStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExecutionStatus(const ExecutionStatus& from) : ExecutionStatus(nullptr, from) {}
  inline ExecutionStatus(ExecutionStatus&& from) noexcept
      : ExecutionStatus(nullptr, std::move(from)) {}
  inline ExecutionStatus& operator=(const ExecutionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionStatus& operator=(ExecutionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionStatus* internal_default_instance() {
    return reinterpret_cast<const ExecutionStatus*>(
        &_ExecutionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ExecutionStatus& a, ExecutionStatus& b) { a.Swap(&b); }
  inline void Swap(ExecutionStatus* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionStatus* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExecutionStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExecutionStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExecutionStatus& from) { ExecutionStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExecutionStatus* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.ExecutionStatus"; }

 protected:
  explicit ExecutionStatus(::google::protobuf::Arena* arena);
  ExecutionStatus(::google::protobuf::Arena* arena, const ExecutionStatus& from);
  ExecutionStatus(::google::protobuf::Arena* arena, ExecutionStatus&& from) noexcept
      : ExecutionStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using StatusCode = ExecutionStatus_StatusCode;
  static constexpr StatusCode UNSPECIFIED = ExecutionStatus_StatusCode_UNSPECIFIED;
  static constexpr StatusCode SUCCESS = ExecutionStatus_StatusCode_SUCCESS;
  static constexpr StatusCode FAILED = ExecutionStatus_StatusCode_FAILED;
  static inline bool StatusCode_IsValid(int value) {
    return ExecutionStatus_StatusCode_IsValid(value);
  }
  static constexpr StatusCode StatusCode_MIN = ExecutionStatus_StatusCode_StatusCode_MIN;
  static constexpr StatusCode StatusCode_MAX = ExecutionStatus_StatusCode_StatusCode_MAX;
  static constexpr int StatusCode_ARRAYSIZE = ExecutionStatus_StatusCode_StatusCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* StatusCode_descriptor() {
    return ExecutionStatus_StatusCode_descriptor();
  }
  template <typename T>
  static inline const std::string& StatusCode_Name(T value) {
    return ExecutionStatus_StatusCode_Name(value);
  }
  static inline bool StatusCode_Parse(absl::string_view name, StatusCode* value) {
    return ExecutionStatus_StatusCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kStatusCodeFieldNumber = 1,
  };
  // string message = 2;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .smart_pkg_delivery.ExecutionStatus.StatusCode status_code = 1;
  bool has_status_code() const;
  void clear_status_code() ;
  ::smart_pkg_delivery::ExecutionStatus_StatusCode status_code() const;
  void set_status_code(::smart_pkg_delivery::ExecutionStatus_StatusCode value);

  private:
  ::smart_pkg_delivery::ExecutionStatus_StatusCode _internal_status_code() const;
  void _internal_set_status_code(::smart_pkg_delivery::ExecutionStatus_StatusCode value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.ExecutionStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExecutionStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    int status_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class Elevator_Status final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.Elevator.Status) */ {
 public:
  inline Elevator_Status() : Elevator_Status(nullptr) {}
  ~Elevator_Status() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Elevator_Status* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Elevator_Status));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Elevator_Status(
      ::google::protobuf::internal::ConstantInitialized);

  inline Elevator_Status(const Elevator_Status& from) : Elevator_Status(nullptr, from) {}
  inline Elevator_Status(Elevator_Status&& from) noexcept
      : Elevator_Status(nullptr, std::move(from)) {}
  inline Elevator_Status& operator=(const Elevator_Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Elevator_Status& operator=(Elevator_Status&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Elevator_Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Elevator_Status* internal_default_instance() {
    return reinterpret_cast<const Elevator_Status*>(
        &_Elevator_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(Elevator_Status& a, Elevator_Status& b) { a.Swap(&b); }
  inline void Swap(Elevator_Status* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Elevator_Status* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Elevator_Status* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Elevator_Status>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Elevator_Status& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Elevator_Status& from) { Elevator_Status::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Elevator_Status* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.Elevator.Status"; }

 protected:
  explicit Elevator_Status(::google::protobuf::Arena* arena);
  Elevator_Status(::google::protobuf::Arena* arena, const Elevator_Status& from);
  Elevator_Status(::google::protobuf::Arena* arena, Elevator_Status&& from) noexcept
      : Elevator_Status(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCurrentFloorFieldNumber = 1,
    kDoorOpenStatusFieldNumber = 2,
  };
  // uint32 current_floor = 1;
  bool has_current_floor() const;
  void clear_current_floor() ;
  ::uint32_t current_floor() const;
  void set_current_floor(::uint32_t value);

  private:
  ::uint32_t _internal_current_floor() const;
  void _internal_set_current_floor(::uint32_t value);

  public:
  // .smart_pkg_delivery.Elevator.DoorOpenStatus door_open_status = 2;
  bool has_door_open_status() const;
  void clear_door_open_status() ;
  ::smart_pkg_delivery::Elevator_DoorOpenStatus door_open_status() const;
  void set_door_open_status(::smart_pkg_delivery::Elevator_DoorOpenStatus value);

  private:
  ::smart_pkg_delivery::Elevator_DoorOpenStatus _internal_door_open_status() const;
  void _internal_set_door_open_status(::smart_pkg_delivery::Elevator_DoorOpenStatus value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.Elevator.Status)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Elevator_Status& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t current_floor_;
    int door_open_status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class DeliveryStatusEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.DeliveryStatusEvent) */ {
 public:
  inline DeliveryStatusEvent() : DeliveryStatusEvent(nullptr) {}
  ~DeliveryStatusEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeliveryStatusEvent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeliveryStatusEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeliveryStatusEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeliveryStatusEvent(const DeliveryStatusEvent& from) : DeliveryStatusEvent(nullptr, from) {}
  inline DeliveryStatusEvent(DeliveryStatusEvent&& from) noexcept
      : DeliveryStatusEvent(nullptr, std::move(from)) {}
  inline DeliveryStatusEvent& operator=(const DeliveryStatusEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeliveryStatusEvent& operator=(DeliveryStatusEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeliveryStatusEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeliveryStatusEvent* internal_default_instance() {
    return reinterpret_cast<const DeliveryStatusEvent*>(
        &_DeliveryStatusEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(DeliveryStatusEvent& a, DeliveryStatusEvent& b) { a.Swap(&b); }
  inline void Swap(DeliveryStatusEvent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeliveryStatusEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeliveryStatusEvent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeliveryStatusEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeliveryStatusEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeliveryStatusEvent& from) { DeliveryStatusEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeliveryStatusEvent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.DeliveryStatusEvent"; }

 protected:
  explicit DeliveryStatusEvent(::google::protobuf::Arena* arena);
  DeliveryStatusEvent(::google::protobuf::Arena* arena, const DeliveryStatusEvent& from);
  DeliveryStatusEvent(::google::protobuf::Arena* arena, DeliveryStatusEvent&& from) noexcept
      : DeliveryStatusEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeliveryRobotIdFieldNumber = 1,
    kDeliveryStatusFieldNumber = 2,
  };
  // uint32 delivery_robot_id = 1;
  bool has_delivery_robot_id() const;
  void clear_delivery_robot_id() ;
  ::uint32_t delivery_robot_id() const;
  void set_delivery_robot_id(::uint32_t value);

  private:
  ::uint32_t _internal_delivery_robot_id() const;
  void _internal_set_delivery_robot_id(::uint32_t value);

  public:
  // .smart_pkg_delivery.DeliveryRobot.DeliveryStatus delivery_status = 2;
  bool has_delivery_status() const;
  void clear_delivery_status() ;
  ::smart_pkg_delivery::DeliveryRobot_DeliveryStatus delivery_status() const;
  void set_delivery_status(::smart_pkg_delivery::DeliveryRobot_DeliveryStatus value);

  private:
  ::smart_pkg_delivery::DeliveryRobot_DeliveryStatus _internal_delivery_status() const;
  void _internal_set_delivery_status(::smart_pkg_delivery::DeliveryRobot_DeliveryStatus value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.DeliveryStatusEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeliveryStatusEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t delivery_robot_id_;
    int delivery_status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class DeliveryRobot final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.DeliveryRobot) */ {
 public:
  inline DeliveryRobot() : DeliveryRobot(nullptr) {}
  ~DeliveryRobot() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeliveryRobot* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeliveryRobot));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeliveryRobot(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeliveryRobot(const DeliveryRobot& from) : DeliveryRobot(nullptr, from) {}
  inline DeliveryRobot(DeliveryRobot&& from) noexcept
      : DeliveryRobot(nullptr, std::move(from)) {}
  inline DeliveryRobot& operator=(const DeliveryRobot& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeliveryRobot& operator=(DeliveryRobot&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeliveryRobot& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeliveryRobot* internal_default_instance() {
    return reinterpret_cast<const DeliveryRobot*>(
        &_DeliveryRobot_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(DeliveryRobot& a, DeliveryRobot& b) { a.Swap(&b); }
  inline void Swap(DeliveryRobot* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeliveryRobot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeliveryRobot* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeliveryRobot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeliveryRobot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeliveryRobot& from) { DeliveryRobot::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeliveryRobot* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.DeliveryRobot"; }

 protected:
  explicit DeliveryRobot(::google::protobuf::Arena* arena);
  DeliveryRobot(::google::protobuf::Arena* arena, const DeliveryRobot& from);
  DeliveryRobot(::google::protobuf::Arena* arena, DeliveryRobot&& from) noexcept
      : DeliveryRobot(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using DeliveryStatus = DeliveryRobot_DeliveryStatus;
  static constexpr DeliveryStatus UNSPECIFIED = DeliveryRobot_DeliveryStatus_UNSPECIFIED;
  static constexpr DeliveryStatus PENDING = DeliveryRobot_DeliveryStatus_PENDING;
  static constexpr DeliveryStatus IN_TRANSIT = DeliveryRobot_DeliveryStatus_IN_TRANSIT;
  static constexpr DeliveryStatus DELIVERED = DeliveryRobot_DeliveryStatus_DELIVERED;
  static inline bool DeliveryStatus_IsValid(int value) {
    return DeliveryRobot_DeliveryStatus_IsValid(value);
  }
  static constexpr DeliveryStatus DeliveryStatus_MIN = DeliveryRobot_DeliveryStatus_DeliveryStatus_MIN;
  static constexpr DeliveryStatus DeliveryStatus_MAX = DeliveryRobot_DeliveryStatus_DeliveryStatus_MAX;
  static constexpr int DeliveryStatus_ARRAYSIZE = DeliveryRobot_DeliveryStatus_DeliveryStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DeliveryStatus_descriptor() {
    return DeliveryRobot_DeliveryStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& DeliveryStatus_Name(T value) {
    return DeliveryRobot_DeliveryStatus_Name(value);
  }
  static inline bool DeliveryStatus_Parse(absl::string_view name, DeliveryStatus* value) {
    return DeliveryRobot_DeliveryStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kDeliveryStatusFieldNumber = 3,
  };
  // uint32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // .smart_pkg_delivery.DeliveryRobot.DeliveryStatus delivery_status = 3;
  bool has_delivery_status() const;
  void clear_delivery_status() ;
  ::smart_pkg_delivery::DeliveryRobot_DeliveryStatus delivery_status() const;
  void set_delivery_status(::smart_pkg_delivery::DeliveryRobot_DeliveryStatus value);

  private:
  ::smart_pkg_delivery::DeliveryRobot_DeliveryStatus _internal_delivery_status() const;
  void _internal_set_delivery_status(::smart_pkg_delivery::DeliveryRobot_DeliveryStatus value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.DeliveryRobot)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeliveryRobot& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t id_;
    int delivery_status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class ClientRegisterResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.ClientRegisterResponse) */ {
 public:
  inline ClientRegisterResponse() : ClientRegisterResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClientRegisterResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClientRegisterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClientRegisterResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClientRegisterResponse(const ClientRegisterResponse& from) : ClientRegisterResponse(nullptr, from) {}
  inline ClientRegisterResponse(ClientRegisterResponse&& from) noexcept
      : ClientRegisterResponse(nullptr, std::move(from)) {}
  inline ClientRegisterResponse& operator=(const ClientRegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientRegisterResponse& operator=(ClientRegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientRegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientRegisterResponse* internal_default_instance() {
    return reinterpret_cast<const ClientRegisterResponse*>(
        &_ClientRegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ClientRegisterResponse& a, ClientRegisterResponse& b) { a.Swap(&b); }
  inline void Swap(ClientRegisterResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientRegisterResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientRegisterResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ClientRegisterResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClientRegisterResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClientRegisterResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.ClientRegisterResponse"; }

 protected:
  explicit ClientRegisterResponse(::google::protobuf::Arena* arena);
  ClientRegisterResponse(::google::protobuf::Arena* arena, const ClientRegisterResponse& from);
  ClientRegisterResponse(::google::protobuf::Arena* arena, ClientRegisterResponse&& from) noexcept
      : ClientRegisterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.ClientRegisterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClientRegisterResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class ClientRegisterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.ClientRegisterRequest) */ {
 public:
  inline ClientRegisterRequest() : ClientRegisterRequest(nullptr) {}
  ~ClientRegisterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClientRegisterRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClientRegisterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClientRegisterRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClientRegisterRequest(const ClientRegisterRequest& from) : ClientRegisterRequest(nullptr, from) {}
  inline ClientRegisterRequest(ClientRegisterRequest&& from) noexcept
      : ClientRegisterRequest(nullptr, std::move(from)) {}
  inline ClientRegisterRequest& operator=(const ClientRegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientRegisterRequest& operator=(ClientRegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientRegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientRegisterRequest* internal_default_instance() {
    return reinterpret_cast<const ClientRegisterRequest*>(
        &_ClientRegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ClientRegisterRequest& a, ClientRegisterRequest& b) { a.Swap(&b); }
  inline void Swap(ClientRegisterRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientRegisterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientRegisterRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ClientRegisterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClientRegisterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClientRegisterRequest& from) { ClientRegisterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClientRegisterRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.ClientRegisterRequest"; }

 protected:
  explicit ClientRegisterRequest(::google::protobuf::Arena* arena);
  ClientRegisterRequest(::google::protobuf::Arena* arena, const ClientRegisterRequest& from);
  ClientRegisterRequest(::google::protobuf::Arena* arena, ClientRegisterRequest&& from) noexcept
      : ClientRegisterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdentityNameFieldNumber = 3,
    kIdentityTypeFieldNumber = 1,
    kIdentityIdFieldNumber = 2,
  };
  // string identity_name = 3;
  bool has_identity_name() const;
  void clear_identity_name() ;
  const std::string& identity_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_identity_name(Arg_&& arg, Args_... args);
  std::string* mutable_identity_name();
  PROTOBUF_NODISCARD std::string* release_identity_name();
  void set_allocated_identity_name(std::string* value);

  private:
  const std::string& _internal_identity_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity_name(
      const std::string& value);
  std::string* _internal_mutable_identity_name();

  public:
  // .smart_pkg_delivery.NodeType identity_type = 1;
  bool has_identity_type() const;
  void clear_identity_type() ;
  ::smart_pkg_delivery::NodeType identity_type() const;
  void set_identity_type(::smart_pkg_delivery::NodeType value);

  private:
  ::smart_pkg_delivery::NodeType _internal_identity_type() const;
  void _internal_set_identity_type(::smart_pkg_delivery::NodeType value);

  public:
  // uint32 identity_id = 2;
  bool has_identity_id() const;
  void clear_identity_id() ;
  ::uint32_t identity_id() const;
  void set_identity_id(::uint32_t value);

  private:
  ::uint32_t _internal_identity_id() const;
  void _internal_set_identity_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.ClientRegisterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      62, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClientRegisterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr identity_name_;
    int identity_type_;
    ::uint32_t identity_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class AptAddress final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.AptAddress) */ {
 public:
  inline AptAddress() : AptAddress(nullptr) {}
  ~AptAddress() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AptAddress* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AptAddress));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AptAddress(
      ::google::protobuf::internal::ConstantInitialized);

  inline AptAddress(const AptAddress& from) : AptAddress(nullptr, from) {}
  inline AptAddress(AptAddress&& from) noexcept
      : AptAddress(nullptr, std::move(from)) {}
  inline AptAddress& operator=(const AptAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline AptAddress& operator=(AptAddress&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AptAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const AptAddress* internal_default_instance() {
    return reinterpret_cast<const AptAddress*>(
        &_AptAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(AptAddress& a, AptAddress& b) { a.Swap(&b); }
  inline void Swap(AptAddress* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AptAddress* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AptAddress* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AptAddress>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AptAddress& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AptAddress& from) { AptAddress::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AptAddress* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.AptAddress"; }

 protected:
  explicit AptAddress(::google::protobuf::Arena* arena);
  AptAddress(::google::protobuf::Arena* arena, const AptAddress& from);
  AptAddress(::google::protobuf::Arena* arena, AptAddress&& from) noexcept
      : AptAddress(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAptComplexFieldNumber = 1,
    kBuildingNumFieldNumber = 2,
    kUnitNumFieldNumber = 3,
  };
  // string apt_complex = 1;
  bool has_apt_complex() const;
  void clear_apt_complex() ;
  const std::string& apt_complex() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_apt_complex(Arg_&& arg, Args_... args);
  std::string* mutable_apt_complex();
  PROTOBUF_NODISCARD std::string* release_apt_complex();
  void set_allocated_apt_complex(std::string* value);

  private:
  const std::string& _internal_apt_complex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_apt_complex(
      const std::string& value);
  std::string* _internal_mutable_apt_complex();

  public:
  // uint32 building_num = 2;
  bool has_building_num() const;
  void clear_building_num() ;
  ::uint32_t building_num() const;
  void set_building_num(::uint32_t value);

  private:
  ::uint32_t _internal_building_num() const;
  void _internal_set_building_num(::uint32_t value);

  public:
  // uint32 unit_num = 3;
  bool has_unit_num() const;
  void clear_unit_num() ;
  ::uint32_t unit_num() const;
  void set_unit_num(::uint32_t value);

  private:
  ::uint32_t _internal_unit_num() const;
  void _internal_set_unit_num(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.AptAddress)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      49, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AptAddress& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr apt_complex_;
    ::uint32_t building_num_;
    ::uint32_t unit_num_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class AckStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.AckStatus) */ {
 public:
  inline AckStatus() : AckStatus(nullptr) {}
  ~AckStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AckStatus* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AckStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AckStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline AckStatus(const AckStatus& from) : AckStatus(nullptr, from) {}
  inline AckStatus(AckStatus&& from) noexcept
      : AckStatus(nullptr, std::move(from)) {}
  inline AckStatus& operator=(const AckStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckStatus& operator=(AckStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckStatus* internal_default_instance() {
    return reinterpret_cast<const AckStatus*>(
        &_AckStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AckStatus& a, AckStatus& b) { a.Swap(&b); }
  inline void Swap(AckStatus* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckStatus* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AckStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AckStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AckStatus& from) { AckStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AckStatus* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.AckStatus"; }

 protected:
  explicit AckStatus(::google::protobuf::Arena* arena);
  AckStatus(::google::protobuf::Arena* arena, const AckStatus& from);
  AckStatus(::google::protobuf::Arena* arena, AckStatus&& from) noexcept
      : AckStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using StatusCode = AckStatus_StatusCode;
  static constexpr StatusCode UNSPECIFIED = AckStatus_StatusCode_UNSPECIFIED;
  static constexpr StatusCode ACK_RECEIVED = AckStatus_StatusCode_ACK_RECEIVED;
  static constexpr StatusCode ACK_INVALID = AckStatus_StatusCode_ACK_INVALID;
  static inline bool StatusCode_IsValid(int value) {
    return AckStatus_StatusCode_IsValid(value);
  }
  static constexpr StatusCode StatusCode_MIN = AckStatus_StatusCode_StatusCode_MIN;
  static constexpr StatusCode StatusCode_MAX = AckStatus_StatusCode_StatusCode_MAX;
  static constexpr int StatusCode_ARRAYSIZE = AckStatus_StatusCode_StatusCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* StatusCode_descriptor() {
    return AckStatus_StatusCode_descriptor();
  }
  template <typename T>
  static inline const std::string& StatusCode_Name(T value) {
    return AckStatus_StatusCode_Name(value);
  }
  static inline bool StatusCode_Parse(absl::string_view name, StatusCode* value) {
    return AckStatus_StatusCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kStatusCodeFieldNumber = 1,
  };
  // string message = 2;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .smart_pkg_delivery.AckStatus.StatusCode status_code = 1;
  bool has_status_code() const;
  void clear_status_code() ;
  ::smart_pkg_delivery::AckStatus_StatusCode status_code() const;
  void set_status_code(::smart_pkg_delivery::AckStatus_StatusCode value);

  private:
  ::smart_pkg_delivery::AckStatus_StatusCode _internal_status_code() const;
  void _internal_set_status_code(::smart_pkg_delivery::AckStatus_StatusCode value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.AckStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      44, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AckStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    int status_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class User final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(User* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(User));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR User(
      ::google::protobuf::internal::ConstantInitialized);

  inline User(const User& from) : User(nullptr, from) {}
  inline User(User&& from) noexcept
      : User(nullptr, std::move(from)) {}
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
        &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(User& a, User& b) { a.Swap(&b); }
  inline void Swap(User* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<User>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const User& from) { User::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(User* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.User"; }

 protected:
  explicit User(::google::protobuf::Arena* arena);
  User(::google::protobuf::Arena* arena, const User& from);
  User(::google::protobuf::Arena* arena, User&& from) noexcept
      : User(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddressFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // .smart_pkg_delivery.AptAddress address = 2;
  bool has_address() const;
  void clear_address() ;
  const ::smart_pkg_delivery::AptAddress& address() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::AptAddress* release_address();
  ::smart_pkg_delivery::AptAddress* mutable_address();
  void set_allocated_address(::smart_pkg_delivery::AptAddress* value);
  void unsafe_arena_set_allocated_address(::smart_pkg_delivery::AptAddress* value);
  ::smart_pkg_delivery::AptAddress* unsafe_arena_release_address();

  private:
  const ::smart_pkg_delivery::AptAddress& _internal_address() const;
  ::smart_pkg_delivery::AptAddress* _internal_mutable_address();

  public:
  // uint32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.User)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const User& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::smart_pkg_delivery::AptAddress* address_;
    ::uint32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class SetElevatorStatusRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.SetElevatorStatusRequest) */ {
 public:
  inline SetElevatorStatusRequest() : SetElevatorStatusRequest(nullptr) {}
  ~SetElevatorStatusRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetElevatorStatusRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetElevatorStatusRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetElevatorStatusRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetElevatorStatusRequest(const SetElevatorStatusRequest& from) : SetElevatorStatusRequest(nullptr, from) {}
  inline SetElevatorStatusRequest(SetElevatorStatusRequest&& from) noexcept
      : SetElevatorStatusRequest(nullptr, std::move(from)) {}
  inline SetElevatorStatusRequest& operator=(const SetElevatorStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetElevatorStatusRequest& operator=(SetElevatorStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetElevatorStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetElevatorStatusRequest* internal_default_instance() {
    return reinterpret_cast<const SetElevatorStatusRequest*>(
        &_SetElevatorStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SetElevatorStatusRequest& a, SetElevatorStatusRequest& b) { a.Swap(&b); }
  inline void Swap(SetElevatorStatusRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetElevatorStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetElevatorStatusRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetElevatorStatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetElevatorStatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetElevatorStatusRequest& from) { SetElevatorStatusRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetElevatorStatusRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.SetElevatorStatusRequest"; }

 protected:
  explicit SetElevatorStatusRequest(::google::protobuf::Arena* arena);
  SetElevatorStatusRequest(::google::protobuf::Arena* arena, const SetElevatorStatusRequest& from);
  SetElevatorStatusRequest(::google::protobuf::Arena* arena, SetElevatorStatusRequest&& from) noexcept
      : SetElevatorStatusRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kElevatorStatusFieldNumber = 2,
    kElevatorIdFieldNumber = 1,
  };
  // .smart_pkg_delivery.Elevator.Status elevator_status = 2;
  bool has_elevator_status() const;
  void clear_elevator_status() ;
  const ::smart_pkg_delivery::Elevator_Status& elevator_status() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::Elevator_Status* release_elevator_status();
  ::smart_pkg_delivery::Elevator_Status* mutable_elevator_status();
  void set_allocated_elevator_status(::smart_pkg_delivery::Elevator_Status* value);
  void unsafe_arena_set_allocated_elevator_status(::smart_pkg_delivery::Elevator_Status* value);
  ::smart_pkg_delivery::Elevator_Status* unsafe_arena_release_elevator_status();

  private:
  const ::smart_pkg_delivery::Elevator_Status& _internal_elevator_status() const;
  ::smart_pkg_delivery::Elevator_Status* _internal_mutable_elevator_status();

  public:
  // uint32 elevator_id = 1;
  bool has_elevator_id() const;
  void clear_elevator_id() ;
  ::uint32_t elevator_id() const;
  void set_elevator_id(::uint32_t value);

  private:
  ::uint32_t _internal_elevator_id() const;
  void _internal_set_elevator_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.SetElevatorStatusRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetElevatorStatusRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::smart_pkg_delivery::Elevator_Status* elevator_status_;
    ::uint32_t elevator_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class PkgRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.PkgRoom) */ {
 public:
  inline PkgRoom() : PkgRoom(nullptr) {}
  ~PkgRoom() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PkgRoom* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PkgRoom));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PkgRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline PkgRoom(const PkgRoom& from) : PkgRoom(nullptr, from) {}
  inline PkgRoom(PkgRoom&& from) noexcept
      : PkgRoom(nullptr, std::move(from)) {}
  inline PkgRoom& operator=(const PkgRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline PkgRoom& operator=(PkgRoom&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PkgRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const PkgRoom* internal_default_instance() {
    return reinterpret_cast<const PkgRoom*>(
        &_PkgRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(PkgRoom& a, PkgRoom& b) { a.Swap(&b); }
  inline void Swap(PkgRoom* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PkgRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PkgRoom* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PkgRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PkgRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PkgRoom& from) { PkgRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PkgRoom* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.PkgRoom"; }

 protected:
  explicit PkgRoom(::google::protobuf::Arena* arena);
  PkgRoom(::google::protobuf::Arena* arena, const PkgRoom& from);
  PkgRoom(::google::protobuf::Arena* arena, PkgRoom&& from) noexcept
      : PkgRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Locker = PkgRoom_Locker;

  // accessors -------------------------------------------------------
  enum : int {
    kLockersFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .smart_pkg_delivery.PkgRoom.Locker lockers = 2;
  int lockers_size() const;
  private:
  int _internal_lockers_size() const;

  public:
  void clear_lockers() ;
  ::smart_pkg_delivery::PkgRoom_Locker* mutable_lockers(int index);
  ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::PkgRoom_Locker>* mutable_lockers();

  private:
  const ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::PkgRoom_Locker>& _internal_lockers() const;
  ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::PkgRoom_Locker>* _internal_mutable_lockers();
  public:
  const ::smart_pkg_delivery::PkgRoom_Locker& lockers(int index) const;
  ::smart_pkg_delivery::PkgRoom_Locker* add_lockers();
  const ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::PkgRoom_Locker>& lockers() const;
  // uint32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.PkgRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PkgRoom& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::smart_pkg_delivery::PkgRoom_Locker > lockers_;
    ::uint32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class PkgArrivalEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.PkgArrivalEvent) */ {
 public:
  inline PkgArrivalEvent() : PkgArrivalEvent(nullptr) {}
  ~PkgArrivalEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PkgArrivalEvent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PkgArrivalEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PkgArrivalEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline PkgArrivalEvent(const PkgArrivalEvent& from) : PkgArrivalEvent(nullptr, from) {}
  inline PkgArrivalEvent(PkgArrivalEvent&& from) noexcept
      : PkgArrivalEvent(nullptr, std::move(from)) {}
  inline PkgArrivalEvent& operator=(const PkgArrivalEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PkgArrivalEvent& operator=(PkgArrivalEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PkgArrivalEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const PkgArrivalEvent* internal_default_instance() {
    return reinterpret_cast<const PkgArrivalEvent*>(
        &_PkgArrivalEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(PkgArrivalEvent& a, PkgArrivalEvent& b) { a.Swap(&b); }
  inline void Swap(PkgArrivalEvent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PkgArrivalEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PkgArrivalEvent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PkgArrivalEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PkgArrivalEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PkgArrivalEvent& from) { PkgArrivalEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PkgArrivalEvent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.PkgArrivalEvent"; }

 protected:
  explicit PkgArrivalEvent(::google::protobuf::Arena* arena);
  PkgArrivalEvent(::google::protobuf::Arena* arena, const PkgArrivalEvent& from);
  PkgArrivalEvent(::google::protobuf::Arena* arena, PkgArrivalEvent&& from) noexcept
      : PkgArrivalEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddressFieldNumber = 1,
  };
  // .smart_pkg_delivery.AptAddress address = 1;
  bool has_address() const;
  void clear_address() ;
  const ::smart_pkg_delivery::AptAddress& address() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::AptAddress* release_address();
  ::smart_pkg_delivery::AptAddress* mutable_address();
  void set_allocated_address(::smart_pkg_delivery::AptAddress* value);
  void unsafe_arena_set_allocated_address(::smart_pkg_delivery::AptAddress* value);
  ::smart_pkg_delivery::AptAddress* unsafe_arena_release_address();

  private:
  const ::smart_pkg_delivery::AptAddress& _internal_address() const;
  ::smart_pkg_delivery::AptAddress* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.PkgArrivalEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PkgArrivalEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::smart_pkg_delivery::AptAddress* address_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class Pkg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.Pkg) */ {
 public:
  inline Pkg() : Pkg(nullptr) {}
  ~Pkg() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Pkg* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Pkg));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pkg(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pkg(const Pkg& from) : Pkg(nullptr, from) {}
  inline Pkg(Pkg&& from) noexcept
      : Pkg(nullptr, std::move(from)) {}
  inline Pkg& operator=(const Pkg& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pkg& operator=(Pkg&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pkg& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pkg* internal_default_instance() {
    return reinterpret_cast<const Pkg*>(
        &_Pkg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(Pkg& a, Pkg& b) { a.Swap(&b); }
  inline void Swap(Pkg* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pkg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pkg* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Pkg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pkg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pkg& from) { Pkg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Pkg* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.Pkg"; }

 protected:
  explicit Pkg(::google::protobuf::Arena* arena);
  Pkg(::google::protobuf::Arena* arena, const Pkg& from);
  Pkg(::google::protobuf::Arena* arena, Pkg&& from) noexcept
      : Pkg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPhotoBytesFieldNumber = 5,
    kAddressFieldNumber = 2,
    kIdFieldNumber = 1,
    kSenderIdFieldNumber = 3,
    kReceiverIdFieldNumber = 4,
  };
  // bytes photo_bytes = 5;
  bool has_photo_bytes() const;
  void clear_photo_bytes() ;
  const std::string& photo_bytes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_photo_bytes(Arg_&& arg, Args_... args);
  std::string* mutable_photo_bytes();
  PROTOBUF_NODISCARD std::string* release_photo_bytes();
  void set_allocated_photo_bytes(std::string* value);

  private:
  const std::string& _internal_photo_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_photo_bytes(
      const std::string& value);
  std::string* _internal_mutable_photo_bytes();

  public:
  // .smart_pkg_delivery.AptAddress address = 2;
  bool has_address() const;
  void clear_address() ;
  const ::smart_pkg_delivery::AptAddress& address() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::AptAddress* release_address();
  ::smart_pkg_delivery::AptAddress* mutable_address();
  void set_allocated_address(::smart_pkg_delivery::AptAddress* value);
  void unsafe_arena_set_allocated_address(::smart_pkg_delivery::AptAddress* value);
  ::smart_pkg_delivery::AptAddress* unsafe_arena_release_address();

  private:
  const ::smart_pkg_delivery::AptAddress& _internal_address() const;
  ::smart_pkg_delivery::AptAddress* _internal_mutable_address();

  public:
  // uint32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // uint32 sender_id = 3;
  bool has_sender_id() const;
  void clear_sender_id() ;
  ::uint32_t sender_id() const;
  void set_sender_id(::uint32_t value);

  private:
  ::uint32_t _internal_sender_id() const;
  void _internal_set_sender_id(::uint32_t value);

  public:
  // uint32 receiver_id = 4;
  bool has_receiver_id() const;
  void clear_receiver_id() ;
  ::uint32_t receiver_id() const;
  void set_receiver_id(::uint32_t value);

  private:
  ::uint32_t _internal_receiver_id() const;
  void _internal_set_receiver_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.Pkg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Pkg& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr photo_bytes_;
    ::smart_pkg_delivery::AptAddress* address_;
    ::uint32_t id_;
    ::uint32_t sender_id_;
    ::uint32_t receiver_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class MoveDeliveryRobotRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.MoveDeliveryRobotRequest) */ {
 public:
  inline MoveDeliveryRobotRequest() : MoveDeliveryRobotRequest(nullptr) {}
  ~MoveDeliveryRobotRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MoveDeliveryRobotRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MoveDeliveryRobotRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveDeliveryRobotRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline MoveDeliveryRobotRequest(const MoveDeliveryRobotRequest& from) : MoveDeliveryRobotRequest(nullptr, from) {}
  inline MoveDeliveryRobotRequest(MoveDeliveryRobotRequest&& from) noexcept
      : MoveDeliveryRobotRequest(nullptr, std::move(from)) {}
  inline MoveDeliveryRobotRequest& operator=(const MoveDeliveryRobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveDeliveryRobotRequest& operator=(MoveDeliveryRobotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveDeliveryRobotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveDeliveryRobotRequest* internal_default_instance() {
    return reinterpret_cast<const MoveDeliveryRobotRequest*>(
        &_MoveDeliveryRobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(MoveDeliveryRobotRequest& a, MoveDeliveryRobotRequest& b) { a.Swap(&b); }
  inline void Swap(MoveDeliveryRobotRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveDeliveryRobotRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveDeliveryRobotRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MoveDeliveryRobotRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveDeliveryRobotRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveDeliveryRobotRequest& from) { MoveDeliveryRobotRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MoveDeliveryRobotRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.MoveDeliveryRobotRequest"; }

 protected:
  explicit MoveDeliveryRobotRequest(::google::protobuf::Arena* arena);
  MoveDeliveryRobotRequest(::google::protobuf::Arena* arena, const MoveDeliveryRobotRequest& from);
  MoveDeliveryRobotRequest(::google::protobuf::Arena* arena, MoveDeliveryRobotRequest&& from) noexcept
      : MoveDeliveryRobotRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDestinationAddressFieldNumber = 2,
    kDeliveryRobotIdFieldNumber = 1,
  };
  // .smart_pkg_delivery.AptAddress destination_address = 2;
  bool has_destination_address() const;
  void clear_destination_address() ;
  const ::smart_pkg_delivery::AptAddress& destination_address() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::AptAddress* release_destination_address();
  ::smart_pkg_delivery::AptAddress* mutable_destination_address();
  void set_allocated_destination_address(::smart_pkg_delivery::AptAddress* value);
  void unsafe_arena_set_allocated_destination_address(::smart_pkg_delivery::AptAddress* value);
  ::smart_pkg_delivery::AptAddress* unsafe_arena_release_destination_address();

  private:
  const ::smart_pkg_delivery::AptAddress& _internal_destination_address() const;
  ::smart_pkg_delivery::AptAddress* _internal_mutable_destination_address();

  public:
  // uint32 delivery_robot_id = 1;
  bool has_delivery_robot_id() const;
  void clear_delivery_robot_id() ;
  ::uint32_t delivery_robot_id() const;
  void set_delivery_robot_id(::uint32_t value);

  private:
  ::uint32_t _internal_delivery_robot_id() const;
  void _internal_set_delivery_robot_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.MoveDeliveryRobotRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MoveDeliveryRobotRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::smart_pkg_delivery::AptAddress* destination_address_;
    ::uint32_t delivery_robot_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class ElevatorStatusEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.ElevatorStatusEvent) */ {
 public:
  inline ElevatorStatusEvent() : ElevatorStatusEvent(nullptr) {}
  ~ElevatorStatusEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ElevatorStatusEvent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ElevatorStatusEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ElevatorStatusEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline ElevatorStatusEvent(const ElevatorStatusEvent& from) : ElevatorStatusEvent(nullptr, from) {}
  inline ElevatorStatusEvent(ElevatorStatusEvent&& from) noexcept
      : ElevatorStatusEvent(nullptr, std::move(from)) {}
  inline ElevatorStatusEvent& operator=(const ElevatorStatusEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElevatorStatusEvent& operator=(ElevatorStatusEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ElevatorStatusEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElevatorStatusEvent* internal_default_instance() {
    return reinterpret_cast<const ElevatorStatusEvent*>(
        &_ElevatorStatusEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ElevatorStatusEvent& a, ElevatorStatusEvent& b) { a.Swap(&b); }
  inline void Swap(ElevatorStatusEvent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElevatorStatusEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElevatorStatusEvent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ElevatorStatusEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ElevatorStatusEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ElevatorStatusEvent& from) { ElevatorStatusEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ElevatorStatusEvent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.ElevatorStatusEvent"; }

 protected:
  explicit ElevatorStatusEvent(::google::protobuf::Arena* arena);
  ElevatorStatusEvent(::google::protobuf::Arena* arena, const ElevatorStatusEvent& from);
  ElevatorStatusEvent(::google::protobuf::Arena* arena, ElevatorStatusEvent&& from) noexcept
      : ElevatorStatusEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kElevatorStatusFieldNumber = 2,
    kElevatorIdFieldNumber = 1,
  };
  // .smart_pkg_delivery.Elevator.Status elevator_status = 2;
  bool has_elevator_status() const;
  void clear_elevator_status() ;
  const ::smart_pkg_delivery::Elevator_Status& elevator_status() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::Elevator_Status* release_elevator_status();
  ::smart_pkg_delivery::Elevator_Status* mutable_elevator_status();
  void set_allocated_elevator_status(::smart_pkg_delivery::Elevator_Status* value);
  void unsafe_arena_set_allocated_elevator_status(::smart_pkg_delivery::Elevator_Status* value);
  ::smart_pkg_delivery::Elevator_Status* unsafe_arena_release_elevator_status();

  private:
  const ::smart_pkg_delivery::Elevator_Status& _internal_elevator_status() const;
  ::smart_pkg_delivery::Elevator_Status* _internal_mutable_elevator_status();

  public:
  // uint32 elevator_id = 1;
  bool has_elevator_id() const;
  void clear_elevator_id() ;
  ::uint32_t elevator_id() const;
  void set_elevator_id(::uint32_t value);

  private:
  ::uint32_t _internal_elevator_id() const;
  void _internal_set_elevator_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.ElevatorStatusEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ElevatorStatusEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::smart_pkg_delivery::Elevator_Status* elevator_status_;
    ::uint32_t elevator_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class Elevator final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.Elevator) */ {
 public:
  inline Elevator() : Elevator(nullptr) {}
  ~Elevator() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Elevator* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Elevator));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Elevator(
      ::google::protobuf::internal::ConstantInitialized);

  inline Elevator(const Elevator& from) : Elevator(nullptr, from) {}
  inline Elevator(Elevator&& from) noexcept
      : Elevator(nullptr, std::move(from)) {}
  inline Elevator& operator=(const Elevator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Elevator& operator=(Elevator&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Elevator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Elevator* internal_default_instance() {
    return reinterpret_cast<const Elevator*>(
        &_Elevator_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(Elevator& a, Elevator& b) { a.Swap(&b); }
  inline void Swap(Elevator* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Elevator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Elevator* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Elevator>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Elevator& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Elevator& from) { Elevator::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Elevator* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.Elevator"; }

 protected:
  explicit Elevator(::google::protobuf::Arena* arena);
  Elevator(::google::protobuf::Arena* arena, const Elevator& from);
  Elevator(::google::protobuf::Arena* arena, Elevator&& from) noexcept
      : Elevator(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Status = Elevator_Status;
  using DoorOpenStatus = Elevator_DoorOpenStatus;
  static constexpr DoorOpenStatus UNSPECIFIED = Elevator_DoorOpenStatus_UNSPECIFIED;
  static constexpr DoorOpenStatus CLOSED = Elevator_DoorOpenStatus_CLOSED;
  static constexpr DoorOpenStatus OPEN = Elevator_DoorOpenStatus_OPEN;
  static inline bool DoorOpenStatus_IsValid(int value) {
    return Elevator_DoorOpenStatus_IsValid(value);
  }
  static constexpr DoorOpenStatus DoorOpenStatus_MIN = Elevator_DoorOpenStatus_DoorOpenStatus_MIN;
  static constexpr DoorOpenStatus DoorOpenStatus_MAX = Elevator_DoorOpenStatus_DoorOpenStatus_MAX;
  static constexpr int DoorOpenStatus_ARRAYSIZE = Elevator_DoorOpenStatus_DoorOpenStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DoorOpenStatus_descriptor() {
    return Elevator_DoorOpenStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& DoorOpenStatus_Name(T value) {
    return Elevator_DoorOpenStatus_Name(value);
  }
  static inline bool DoorOpenStatus_Parse(absl::string_view name, DoorOpenStatus* value) {
    return Elevator_DoorOpenStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // .smart_pkg_delivery.Elevator.Status status = 2;
  bool has_status() const;
  void clear_status() ;
  const ::smart_pkg_delivery::Elevator_Status& status() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::Elevator_Status* release_status();
  ::smart_pkg_delivery::Elevator_Status* mutable_status();
  void set_allocated_status(::smart_pkg_delivery::Elevator_Status* value);
  void unsafe_arena_set_allocated_status(::smart_pkg_delivery::Elevator_Status* value);
  ::smart_pkg_delivery::Elevator_Status* unsafe_arena_release_status();

  private:
  const ::smart_pkg_delivery::Elevator_Status& _internal_status() const;
  ::smart_pkg_delivery::Elevator_Status* _internal_mutable_status();

  public:
  // uint32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.Elevator)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Elevator& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::smart_pkg_delivery::Elevator_Status* status_;
    ::uint32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class Request final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Request* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Request));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Request(
      ::google::protobuf::internal::ConstantInitialized);

  inline Request(const Request& from) : Request(nullptr, from) {}
  inline Request(Request&& from) noexcept
      : Request(nullptr, std::move(from)) {}
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kClientRegisterRequest = 1,
    kGetPkgInfosRequest = 2,
    kSetElevatorStatusRequest = 3,
    kMoveDeliveryRobotRequest = 4,
    REQUEST_TYPE_NOT_SET = 0,
  };
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
        &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Request& a, Request& b) { a.Swap(&b); }
  inline void Swap(Request* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Request>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Request& from) { Request::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Request* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.Request"; }

 protected:
  explicit Request(::google::protobuf::Arena* arena);
  Request(::google::protobuf::Arena* arena, const Request& from);
  Request(::google::protobuf::Arena* arena, Request&& from) noexcept
      : Request(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClientRegisterRequestFieldNumber = 1,
    kGetPkgInfosRequestFieldNumber = 2,
    kSetElevatorStatusRequestFieldNumber = 3,
    kMoveDeliveryRobotRequestFieldNumber = 4,
  };
  // .smart_pkg_delivery.ClientRegisterRequest client_register_request = 1;
  bool has_client_register_request() const;
  private:
  bool _internal_has_client_register_request() const;

  public:
  void clear_client_register_request() ;
  const ::smart_pkg_delivery::ClientRegisterRequest& client_register_request() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::ClientRegisterRequest* release_client_register_request();
  ::smart_pkg_delivery::ClientRegisterRequest* mutable_client_register_request();
  void set_allocated_client_register_request(::smart_pkg_delivery::ClientRegisterRequest* value);
  void unsafe_arena_set_allocated_client_register_request(::smart_pkg_delivery::ClientRegisterRequest* value);
  ::smart_pkg_delivery::ClientRegisterRequest* unsafe_arena_release_client_register_request();

  private:
  const ::smart_pkg_delivery::ClientRegisterRequest& _internal_client_register_request() const;
  ::smart_pkg_delivery::ClientRegisterRequest* _internal_mutable_client_register_request();

  public:
  // .smart_pkg_delivery.GetPkgInfosRequest get_pkg_infos_request = 2;
  bool has_get_pkg_infos_request() const;
  private:
  bool _internal_has_get_pkg_infos_request() const;

  public:
  void clear_get_pkg_infos_request() ;
  const ::smart_pkg_delivery::GetPkgInfosRequest& get_pkg_infos_request() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::GetPkgInfosRequest* release_get_pkg_infos_request();
  ::smart_pkg_delivery::GetPkgInfosRequest* mutable_get_pkg_infos_request();
  void set_allocated_get_pkg_infos_request(::smart_pkg_delivery::GetPkgInfosRequest* value);
  void unsafe_arena_set_allocated_get_pkg_infos_request(::smart_pkg_delivery::GetPkgInfosRequest* value);
  ::smart_pkg_delivery::GetPkgInfosRequest* unsafe_arena_release_get_pkg_infos_request();

  private:
  const ::smart_pkg_delivery::GetPkgInfosRequest& _internal_get_pkg_infos_request() const;
  ::smart_pkg_delivery::GetPkgInfosRequest* _internal_mutable_get_pkg_infos_request();

  public:
  // .smart_pkg_delivery.SetElevatorStatusRequest set_elevator_status_request = 3;
  bool has_set_elevator_status_request() const;
  private:
  bool _internal_has_set_elevator_status_request() const;

  public:
  void clear_set_elevator_status_request() ;
  const ::smart_pkg_delivery::SetElevatorStatusRequest& set_elevator_status_request() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::SetElevatorStatusRequest* release_set_elevator_status_request();
  ::smart_pkg_delivery::SetElevatorStatusRequest* mutable_set_elevator_status_request();
  void set_allocated_set_elevator_status_request(::smart_pkg_delivery::SetElevatorStatusRequest* value);
  void unsafe_arena_set_allocated_set_elevator_status_request(::smart_pkg_delivery::SetElevatorStatusRequest* value);
  ::smart_pkg_delivery::SetElevatorStatusRequest* unsafe_arena_release_set_elevator_status_request();

  private:
  const ::smart_pkg_delivery::SetElevatorStatusRequest& _internal_set_elevator_status_request() const;
  ::smart_pkg_delivery::SetElevatorStatusRequest* _internal_mutable_set_elevator_status_request();

  public:
  // .smart_pkg_delivery.MoveDeliveryRobotRequest move_delivery_robot_request = 4;
  bool has_move_delivery_robot_request() const;
  private:
  bool _internal_has_move_delivery_robot_request() const;

  public:
  void clear_move_delivery_robot_request() ;
  const ::smart_pkg_delivery::MoveDeliveryRobotRequest& move_delivery_robot_request() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::MoveDeliveryRobotRequest* release_move_delivery_robot_request();
  ::smart_pkg_delivery::MoveDeliveryRobotRequest* mutable_move_delivery_robot_request();
  void set_allocated_move_delivery_robot_request(::smart_pkg_delivery::MoveDeliveryRobotRequest* value);
  void unsafe_arena_set_allocated_move_delivery_robot_request(::smart_pkg_delivery::MoveDeliveryRobotRequest* value);
  ::smart_pkg_delivery::MoveDeliveryRobotRequest* unsafe_arena_release_move_delivery_robot_request();

  private:
  const ::smart_pkg_delivery::MoveDeliveryRobotRequest& _internal_move_delivery_robot_request() const;
  ::smart_pkg_delivery::MoveDeliveryRobotRequest* _internal_mutable_move_delivery_robot_request();

  public:
  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.Request)
 private:
  class _Internal;
  void set_has_client_register_request();
  void set_has_get_pkg_infos_request();
  void set_has_set_elevator_status_request();
  void set_has_move_delivery_robot_request();
  inline bool has_request_type() const;
  inline void clear_has_request_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Request& from_msg);
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::smart_pkg_delivery::ClientRegisterRequest* client_register_request_;
      ::smart_pkg_delivery::GetPkgInfosRequest* get_pkg_infos_request_;
      ::smart_pkg_delivery::SetElevatorStatusRequest* set_elevator_status_request_;
      ::smart_pkg_delivery::MoveDeliveryRobotRequest* move_delivery_robot_request_;
    } request_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class NodeEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.NodeEvent) */ {
 public:
  inline NodeEvent() : NodeEvent(nullptr) {}
  ~NodeEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeEvent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeEvent(const NodeEvent& from) : NodeEvent(nullptr, from) {}
  inline NodeEvent(NodeEvent&& from) noexcept
      : NodeEvent(nullptr, std::move(from)) {}
  inline NodeEvent& operator=(const NodeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeEvent& operator=(NodeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventTypeCase {
    kPkgArrivalEvent = 1,
    kElevatorStatusEvent = 2,
    kDeliveryStatusEvent = 3,
    EVENT_TYPE_NOT_SET = 0,
  };
  static inline const NodeEvent* internal_default_instance() {
    return reinterpret_cast<const NodeEvent*>(
        &_NodeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(NodeEvent& a, NodeEvent& b) { a.Swap(&b); }
  inline void Swap(NodeEvent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeEvent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeEvent& from) { NodeEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeEvent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.NodeEvent"; }

 protected:
  explicit NodeEvent(::google::protobuf::Arena* arena);
  NodeEvent(::google::protobuf::Arena* arena, const NodeEvent& from);
  NodeEvent(::google::protobuf::Arena* arena, NodeEvent&& from) noexcept
      : NodeEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPkgArrivalEventFieldNumber = 1,
    kElevatorStatusEventFieldNumber = 2,
    kDeliveryStatusEventFieldNumber = 3,
  };
  // .smart_pkg_delivery.PkgArrivalEvent pkg_arrival_event = 1;
  bool has_pkg_arrival_event() const;
  private:
  bool _internal_has_pkg_arrival_event() const;

  public:
  void clear_pkg_arrival_event() ;
  const ::smart_pkg_delivery::PkgArrivalEvent& pkg_arrival_event() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::PkgArrivalEvent* release_pkg_arrival_event();
  ::smart_pkg_delivery::PkgArrivalEvent* mutable_pkg_arrival_event();
  void set_allocated_pkg_arrival_event(::smart_pkg_delivery::PkgArrivalEvent* value);
  void unsafe_arena_set_allocated_pkg_arrival_event(::smart_pkg_delivery::PkgArrivalEvent* value);
  ::smart_pkg_delivery::PkgArrivalEvent* unsafe_arena_release_pkg_arrival_event();

  private:
  const ::smart_pkg_delivery::PkgArrivalEvent& _internal_pkg_arrival_event() const;
  ::smart_pkg_delivery::PkgArrivalEvent* _internal_mutable_pkg_arrival_event();

  public:
  // .smart_pkg_delivery.ElevatorStatusEvent elevator_status_event = 2;
  bool has_elevator_status_event() const;
  private:
  bool _internal_has_elevator_status_event() const;

  public:
  void clear_elevator_status_event() ;
  const ::smart_pkg_delivery::ElevatorStatusEvent& elevator_status_event() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::ElevatorStatusEvent* release_elevator_status_event();
  ::smart_pkg_delivery::ElevatorStatusEvent* mutable_elevator_status_event();
  void set_allocated_elevator_status_event(::smart_pkg_delivery::ElevatorStatusEvent* value);
  void unsafe_arena_set_allocated_elevator_status_event(::smart_pkg_delivery::ElevatorStatusEvent* value);
  ::smart_pkg_delivery::ElevatorStatusEvent* unsafe_arena_release_elevator_status_event();

  private:
  const ::smart_pkg_delivery::ElevatorStatusEvent& _internal_elevator_status_event() const;
  ::smart_pkg_delivery::ElevatorStatusEvent* _internal_mutable_elevator_status_event();

  public:
  // .smart_pkg_delivery.DeliveryStatusEvent delivery_status_event = 3;
  bool has_delivery_status_event() const;
  private:
  bool _internal_has_delivery_status_event() const;

  public:
  void clear_delivery_status_event() ;
  const ::smart_pkg_delivery::DeliveryStatusEvent& delivery_status_event() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::DeliveryStatusEvent* release_delivery_status_event();
  ::smart_pkg_delivery::DeliveryStatusEvent* mutable_delivery_status_event();
  void set_allocated_delivery_status_event(::smart_pkg_delivery::DeliveryStatusEvent* value);
  void unsafe_arena_set_allocated_delivery_status_event(::smart_pkg_delivery::DeliveryStatusEvent* value);
  ::smart_pkg_delivery::DeliveryStatusEvent* unsafe_arena_release_delivery_status_event();

  private:
  const ::smart_pkg_delivery::DeliveryStatusEvent& _internal_delivery_status_event() const;
  ::smart_pkg_delivery::DeliveryStatusEvent* _internal_mutable_delivery_status_event();

  public:
  void clear_event_type();
  EventTypeCase event_type_case() const;
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.NodeEvent)
 private:
  class _Internal;
  void set_has_pkg_arrival_event();
  void set_has_elevator_status_event();
  void set_has_delivery_status_event();
  inline bool has_event_type() const;
  inline void clear_has_event_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeEvent& from_msg);
    union EventTypeUnion {
      constexpr EventTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::smart_pkg_delivery::PkgArrivalEvent* pkg_arrival_event_;
      ::smart_pkg_delivery::ElevatorStatusEvent* elevator_status_event_;
      ::smart_pkg_delivery::DeliveryStatusEvent* delivery_status_event_;
    } event_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class GetPkgInfoResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.GetPkgInfoResponse) */ {
 public:
  inline GetPkgInfoResponse() : GetPkgInfoResponse(nullptr) {}
  ~GetPkgInfoResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetPkgInfoResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetPkgInfoResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetPkgInfoResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetPkgInfoResponse(const GetPkgInfoResponse& from) : GetPkgInfoResponse(nullptr, from) {}
  inline GetPkgInfoResponse(GetPkgInfoResponse&& from) noexcept
      : GetPkgInfoResponse(nullptr, std::move(from)) {}
  inline GetPkgInfoResponse& operator=(const GetPkgInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPkgInfoResponse& operator=(GetPkgInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPkgInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPkgInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetPkgInfoResponse*>(
        &_GetPkgInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GetPkgInfoResponse& a, GetPkgInfoResponse& b) { a.Swap(&b); }
  inline void Swap(GetPkgInfoResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPkgInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPkgInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetPkgInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPkgInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetPkgInfoResponse& from) { GetPkgInfoResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetPkgInfoResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.GetPkgInfoResponse"; }

 protected:
  explicit GetPkgInfoResponse(::google::protobuf::Arena* arena);
  GetPkgInfoResponse(::google::protobuf::Arena* arena, const GetPkgInfoResponse& from);
  GetPkgInfoResponse(::google::protobuf::Arena* arena, GetPkgInfoResponse&& from) noexcept
      : GetPkgInfoResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPkgsFieldNumber = 1,
  };
  // repeated .smart_pkg_delivery.Pkg pkgs = 1;
  int pkgs_size() const;
  private:
  int _internal_pkgs_size() const;

  public:
  void clear_pkgs() ;
  ::smart_pkg_delivery::Pkg* mutable_pkgs(int index);
  ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::Pkg>* mutable_pkgs();

  private:
  const ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::Pkg>& _internal_pkgs() const;
  ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::Pkg>* _internal_mutable_pkgs();
  public:
  const ::smart_pkg_delivery::Pkg& pkgs(int index) const;
  ::smart_pkg_delivery::Pkg* add_pkgs();
  const ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::Pkg>& pkgs() const;
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.GetPkgInfoResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetPkgInfoResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::smart_pkg_delivery::Pkg > pkgs_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class Response final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Response* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Response));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Response(
      ::google::protobuf::internal::ConstantInitialized);

  inline Response(const Response& from) : Response(nullptr, from) {}
  inline Response(Response&& from) noexcept
      : Response(nullptr, std::move(from)) {}
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseTypeCase {
    kClientRegisterResponse = 3,
    kGetPkgInfoResponse = 4,
    kSetElevatorStatusResponse = 5,
    kMoveDeliveryRobotResponse = 6,
    RESPONSE_TYPE_NOT_SET = 0,
  };
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
        &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Response& a, Response& b) { a.Swap(&b); }
  inline void Swap(Response* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Response>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Response& from) { Response::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Response* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.Response"; }

 protected:
  explicit Response(::google::protobuf::Arena* arena);
  Response(::google::protobuf::Arena* arena, const Response& from);
  Response(::google::protobuf::Arena* arena, Response&& from) noexcept
      : Response(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAckStatusFieldNumber = 1,
    kExecutionStatusFieldNumber = 2,
    kClientRegisterResponseFieldNumber = 3,
    kGetPkgInfoResponseFieldNumber = 4,
    kSetElevatorStatusResponseFieldNumber = 5,
    kMoveDeliveryRobotResponseFieldNumber = 6,
  };
  // .smart_pkg_delivery.AckStatus ack_status = 1;
  bool has_ack_status() const;
  void clear_ack_status() ;
  const ::smart_pkg_delivery::AckStatus& ack_status() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::AckStatus* release_ack_status();
  ::smart_pkg_delivery::AckStatus* mutable_ack_status();
  void set_allocated_ack_status(::smart_pkg_delivery::AckStatus* value);
  void unsafe_arena_set_allocated_ack_status(::smart_pkg_delivery::AckStatus* value);
  ::smart_pkg_delivery::AckStatus* unsafe_arena_release_ack_status();

  private:
  const ::smart_pkg_delivery::AckStatus& _internal_ack_status() const;
  ::smart_pkg_delivery::AckStatus* _internal_mutable_ack_status();

  public:
  // .smart_pkg_delivery.ExecutionStatus execution_status = 2;
  bool has_execution_status() const;
  void clear_execution_status() ;
  const ::smart_pkg_delivery::ExecutionStatus& execution_status() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::ExecutionStatus* release_execution_status();
  ::smart_pkg_delivery::ExecutionStatus* mutable_execution_status();
  void set_allocated_execution_status(::smart_pkg_delivery::ExecutionStatus* value);
  void unsafe_arena_set_allocated_execution_status(::smart_pkg_delivery::ExecutionStatus* value);
  ::smart_pkg_delivery::ExecutionStatus* unsafe_arena_release_execution_status();

  private:
  const ::smart_pkg_delivery::ExecutionStatus& _internal_execution_status() const;
  ::smart_pkg_delivery::ExecutionStatus* _internal_mutable_execution_status();

  public:
  // .smart_pkg_delivery.ClientRegisterResponse client_register_response = 3;
  bool has_client_register_response() const;
  private:
  bool _internal_has_client_register_response() const;

  public:
  void clear_client_register_response() ;
  const ::smart_pkg_delivery::ClientRegisterResponse& client_register_response() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::ClientRegisterResponse* release_client_register_response();
  ::smart_pkg_delivery::ClientRegisterResponse* mutable_client_register_response();
  void set_allocated_client_register_response(::smart_pkg_delivery::ClientRegisterResponse* value);
  void unsafe_arena_set_allocated_client_register_response(::smart_pkg_delivery::ClientRegisterResponse* value);
  ::smart_pkg_delivery::ClientRegisterResponse* unsafe_arena_release_client_register_response();

  private:
  const ::smart_pkg_delivery::ClientRegisterResponse& _internal_client_register_response() const;
  ::smart_pkg_delivery::ClientRegisterResponse* _internal_mutable_client_register_response();

  public:
  // .smart_pkg_delivery.GetPkgInfoResponse get_pkg_info_response = 4;
  bool has_get_pkg_info_response() const;
  private:
  bool _internal_has_get_pkg_info_response() const;

  public:
  void clear_get_pkg_info_response() ;
  const ::smart_pkg_delivery::GetPkgInfoResponse& get_pkg_info_response() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::GetPkgInfoResponse* release_get_pkg_info_response();
  ::smart_pkg_delivery::GetPkgInfoResponse* mutable_get_pkg_info_response();
  void set_allocated_get_pkg_info_response(::smart_pkg_delivery::GetPkgInfoResponse* value);
  void unsafe_arena_set_allocated_get_pkg_info_response(::smart_pkg_delivery::GetPkgInfoResponse* value);
  ::smart_pkg_delivery::GetPkgInfoResponse* unsafe_arena_release_get_pkg_info_response();

  private:
  const ::smart_pkg_delivery::GetPkgInfoResponse& _internal_get_pkg_info_response() const;
  ::smart_pkg_delivery::GetPkgInfoResponse* _internal_mutable_get_pkg_info_response();

  public:
  // .smart_pkg_delivery.SetElevatorStatusResponse set_elevator_status_response = 5;
  bool has_set_elevator_status_response() const;
  private:
  bool _internal_has_set_elevator_status_response() const;

  public:
  void clear_set_elevator_status_response() ;
  const ::smart_pkg_delivery::SetElevatorStatusResponse& set_elevator_status_response() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::SetElevatorStatusResponse* release_set_elevator_status_response();
  ::smart_pkg_delivery::SetElevatorStatusResponse* mutable_set_elevator_status_response();
  void set_allocated_set_elevator_status_response(::smart_pkg_delivery::SetElevatorStatusResponse* value);
  void unsafe_arena_set_allocated_set_elevator_status_response(::smart_pkg_delivery::SetElevatorStatusResponse* value);
  ::smart_pkg_delivery::SetElevatorStatusResponse* unsafe_arena_release_set_elevator_status_response();

  private:
  const ::smart_pkg_delivery::SetElevatorStatusResponse& _internal_set_elevator_status_response() const;
  ::smart_pkg_delivery::SetElevatorStatusResponse* _internal_mutable_set_elevator_status_response();

  public:
  // .smart_pkg_delivery.MoveDeliveryRobotResponse move_delivery_robot_response = 6;
  bool has_move_delivery_robot_response() const;
  private:
  bool _internal_has_move_delivery_robot_response() const;

  public:
  void clear_move_delivery_robot_response() ;
  const ::smart_pkg_delivery::MoveDeliveryRobotResponse& move_delivery_robot_response() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::MoveDeliveryRobotResponse* release_move_delivery_robot_response();
  ::smart_pkg_delivery::MoveDeliveryRobotResponse* mutable_move_delivery_robot_response();
  void set_allocated_move_delivery_robot_response(::smart_pkg_delivery::MoveDeliveryRobotResponse* value);
  void unsafe_arena_set_allocated_move_delivery_robot_response(::smart_pkg_delivery::MoveDeliveryRobotResponse* value);
  ::smart_pkg_delivery::MoveDeliveryRobotResponse* unsafe_arena_release_move_delivery_robot_response();

  private:
  const ::smart_pkg_delivery::MoveDeliveryRobotResponse& _internal_move_delivery_robot_response() const;
  ::smart_pkg_delivery::MoveDeliveryRobotResponse* _internal_mutable_move_delivery_robot_response();

  public:
  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.Response)
 private:
  class _Internal;
  void set_has_client_register_response();
  void set_has_get_pkg_info_response();
  void set_has_set_elevator_status_response();
  void set_has_move_delivery_robot_response();
  inline bool has_response_type() const;
  inline void clear_has_response_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 6, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Response& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::smart_pkg_delivery::AckStatus* ack_status_;
    ::smart_pkg_delivery::ExecutionStatus* execution_status_;
    union ResponseTypeUnion {
      constexpr ResponseTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::smart_pkg_delivery::ClientRegisterResponse* client_register_response_;
      ::smart_pkg_delivery::GetPkgInfoResponse* get_pkg_info_response_;
      ::smart_pkg_delivery::SetElevatorStatusResponse* set_elevator_status_response_;
      ::smart_pkg_delivery::MoveDeliveryRobotResponse* move_delivery_robot_response_;
    } response_type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};
// -------------------------------------------------------------------

class InteractionMsg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:smart_pkg_delivery.InteractionMsg) */ {
 public:
  inline InteractionMsg() : InteractionMsg(nullptr) {}
  ~InteractionMsg() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InteractionMsg* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InteractionMsg));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InteractionMsg(
      ::google::protobuf::internal::ConstantInitialized);

  inline InteractionMsg(const InteractionMsg& from) : InteractionMsg(nullptr, from) {}
  inline InteractionMsg(InteractionMsg&& from) noexcept
      : InteractionMsg(nullptr, std::move(from)) {}
  inline InteractionMsg& operator=(const InteractionMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline InteractionMsg& operator=(InteractionMsg&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InteractionMsg& default_instance() {
    return *internal_default_instance();
  }
  enum MsgTypeCase {
    kRequest = 7,
    kResponse = 8,
    kNodeEvent = 9,
    MSG_TYPE_NOT_SET = 0,
  };
  static inline const InteractionMsg* internal_default_instance() {
    return reinterpret_cast<const InteractionMsg*>(
        &_InteractionMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(InteractionMsg& a, InteractionMsg& b) { a.Swap(&b); }
  inline void Swap(InteractionMsg* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InteractionMsg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InteractionMsg* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InteractionMsg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InteractionMsg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InteractionMsg& from) { InteractionMsg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InteractionMsg* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "smart_pkg_delivery.InteractionMsg"; }

 protected:
  explicit InteractionMsg(::google::protobuf::Arena* arena);
  InteractionMsg(::google::protobuf::Arena* arena, const InteractionMsg& from);
  InteractionMsg(::google::protobuf::Arena* arena, InteractionMsg&& from) noexcept
      : InteractionMsg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSrcNameFieldNumber = 3,
    kDestNameFieldNumber = 6,
    kSrcTypeFieldNumber = 1,
    kSrcIdFieldNumber = 2,
    kDestTypeFieldNumber = 4,
    kDestIdFieldNumber = 5,
    kRequestFieldNumber = 7,
    kResponseFieldNumber = 8,
    kNodeEventFieldNumber = 9,
  };
  // string src_name = 3;
  bool has_src_name() const;
  void clear_src_name() ;
  const std::string& src_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_name(Arg_&& arg, Args_... args);
  std::string* mutable_src_name();
  PROTOBUF_NODISCARD std::string* release_src_name();
  void set_allocated_src_name(std::string* value);

  private:
  const std::string& _internal_src_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_name(
      const std::string& value);
  std::string* _internal_mutable_src_name();

  public:
  // string dest_name = 6;
  bool has_dest_name() const;
  void clear_dest_name() ;
  const std::string& dest_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dest_name(Arg_&& arg, Args_... args);
  std::string* mutable_dest_name();
  PROTOBUF_NODISCARD std::string* release_dest_name();
  void set_allocated_dest_name(std::string* value);

  private:
  const std::string& _internal_dest_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest_name(
      const std::string& value);
  std::string* _internal_mutable_dest_name();

  public:
  // .smart_pkg_delivery.NodeType src_type = 1;
  bool has_src_type() const;
  void clear_src_type() ;
  ::smart_pkg_delivery::NodeType src_type() const;
  void set_src_type(::smart_pkg_delivery::NodeType value);

  private:
  ::smart_pkg_delivery::NodeType _internal_src_type() const;
  void _internal_set_src_type(::smart_pkg_delivery::NodeType value);

  public:
  // uint32 src_id = 2;
  bool has_src_id() const;
  void clear_src_id() ;
  ::uint32_t src_id() const;
  void set_src_id(::uint32_t value);

  private:
  ::uint32_t _internal_src_id() const;
  void _internal_set_src_id(::uint32_t value);

  public:
  // .smart_pkg_delivery.NodeType dest_type = 4;
  bool has_dest_type() const;
  void clear_dest_type() ;
  ::smart_pkg_delivery::NodeType dest_type() const;
  void set_dest_type(::smart_pkg_delivery::NodeType value);

  private:
  ::smart_pkg_delivery::NodeType _internal_dest_type() const;
  void _internal_set_dest_type(::smart_pkg_delivery::NodeType value);

  public:
  // uint32 dest_id = 5;
  bool has_dest_id() const;
  void clear_dest_id() ;
  ::uint32_t dest_id() const;
  void set_dest_id(::uint32_t value);

  private:
  ::uint32_t _internal_dest_id() const;
  void _internal_set_dest_id(::uint32_t value);

  public:
  // .smart_pkg_delivery.Request request = 7;
  bool has_request() const;
  private:
  bool _internal_has_request() const;

  public:
  void clear_request() ;
  const ::smart_pkg_delivery::Request& request() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::Request* release_request();
  ::smart_pkg_delivery::Request* mutable_request();
  void set_allocated_request(::smart_pkg_delivery::Request* value);
  void unsafe_arena_set_allocated_request(::smart_pkg_delivery::Request* value);
  ::smart_pkg_delivery::Request* unsafe_arena_release_request();

  private:
  const ::smart_pkg_delivery::Request& _internal_request() const;
  ::smart_pkg_delivery::Request* _internal_mutable_request();

  public:
  // .smart_pkg_delivery.Response response = 8;
  bool has_response() const;
  private:
  bool _internal_has_response() const;

  public:
  void clear_response() ;
  const ::smart_pkg_delivery::Response& response() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::Response* release_response();
  ::smart_pkg_delivery::Response* mutable_response();
  void set_allocated_response(::smart_pkg_delivery::Response* value);
  void unsafe_arena_set_allocated_response(::smart_pkg_delivery::Response* value);
  ::smart_pkg_delivery::Response* unsafe_arena_release_response();

  private:
  const ::smart_pkg_delivery::Response& _internal_response() const;
  ::smart_pkg_delivery::Response* _internal_mutable_response();

  public:
  // .smart_pkg_delivery.NodeEvent node_event = 9;
  bool has_node_event() const;
  private:
  bool _internal_has_node_event() const;

  public:
  void clear_node_event() ;
  const ::smart_pkg_delivery::NodeEvent& node_event() const;
  PROTOBUF_NODISCARD ::smart_pkg_delivery::NodeEvent* release_node_event();
  ::smart_pkg_delivery::NodeEvent* mutable_node_event();
  void set_allocated_node_event(::smart_pkg_delivery::NodeEvent* value);
  void unsafe_arena_set_allocated_node_event(::smart_pkg_delivery::NodeEvent* value);
  ::smart_pkg_delivery::NodeEvent* unsafe_arena_release_node_event();

  private:
  const ::smart_pkg_delivery::NodeEvent& _internal_node_event() const;
  ::smart_pkg_delivery::NodeEvent* _internal_mutable_node_event();

  public:
  void clear_msg_type();
  MsgTypeCase msg_type_case() const;
  // @@protoc_insertion_point(class_scope:smart_pkg_delivery.InteractionMsg)
 private:
  class _Internal;
  void set_has_request();
  void set_has_response();
  void set_has_node_event();
  inline bool has_msg_type() const;
  inline void clear_has_msg_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 9, 3,
      67, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InteractionMsg& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr src_name_;
    ::google::protobuf::internal::ArenaStringPtr dest_name_;
    int src_type_;
    ::uint32_t src_id_;
    int dest_type_;
    ::uint32_t dest_id_;
    union MsgTypeUnion {
      constexpr MsgTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::smart_pkg_delivery::Request* request_;
      ::smart_pkg_delivery::Response* response_;
      ::smart_pkg_delivery::NodeEvent* node_event_;
    } msg_type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fpkg_5fdelivery_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InteractionMsg

// .smart_pkg_delivery.NodeType src_type = 1;
inline bool InteractionMsg::has_src_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InteractionMsg::clear_src_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::smart_pkg_delivery::NodeType InteractionMsg::src_type() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.InteractionMsg.src_type)
  return _internal_src_type();
}
inline void InteractionMsg::set_src_type(::smart_pkg_delivery::NodeType value) {
  _internal_set_src_type(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.InteractionMsg.src_type)
}
inline ::smart_pkg_delivery::NodeType InteractionMsg::_internal_src_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::smart_pkg_delivery::NodeType>(_impl_.src_type_);
}
inline void InteractionMsg::_internal_set_src_type(::smart_pkg_delivery::NodeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_type_ = value;
}

// uint32 src_id = 2;
inline bool InteractionMsg::has_src_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void InteractionMsg::clear_src_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t InteractionMsg::src_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.InteractionMsg.src_id)
  return _internal_src_id();
}
inline void InteractionMsg::set_src_id(::uint32_t value) {
  _internal_set_src_id(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.InteractionMsg.src_id)
}
inline ::uint32_t InteractionMsg::_internal_src_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.src_id_;
}
inline void InteractionMsg::_internal_set_src_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_id_ = value;
}

// string src_name = 3;
inline bool InteractionMsg::has_src_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InteractionMsg::clear_src_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InteractionMsg::src_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.InteractionMsg.src_name)
  return _internal_src_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InteractionMsg::set_src_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.src_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.InteractionMsg.src_name)
}
inline std::string* InteractionMsg::mutable_src_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_src_name();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.InteractionMsg.src_name)
  return _s;
}
inline const std::string& InteractionMsg::_internal_src_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.src_name_.Get();
}
inline void InteractionMsg::_internal_set_src_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.src_name_.Set(value, GetArena());
}
inline std::string* InteractionMsg::_internal_mutable_src_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.src_name_.Mutable( GetArena());
}
inline std::string* InteractionMsg::release_src_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.InteractionMsg.src_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.src_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.src_name_.Set("", GetArena());
  }
  return released;
}
inline void InteractionMsg::set_allocated_src_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.src_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.src_name_.IsDefault()) {
    _impl_.src_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.InteractionMsg.src_name)
}

// .smart_pkg_delivery.NodeType dest_type = 4;
inline bool InteractionMsg::has_dest_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void InteractionMsg::clear_dest_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dest_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::smart_pkg_delivery::NodeType InteractionMsg::dest_type() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.InteractionMsg.dest_type)
  return _internal_dest_type();
}
inline void InteractionMsg::set_dest_type(::smart_pkg_delivery::NodeType value) {
  _internal_set_dest_type(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.InteractionMsg.dest_type)
}
inline ::smart_pkg_delivery::NodeType InteractionMsg::_internal_dest_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::smart_pkg_delivery::NodeType>(_impl_.dest_type_);
}
inline void InteractionMsg::_internal_set_dest_type(::smart_pkg_delivery::NodeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dest_type_ = value;
}

// uint32 dest_id = 5;
inline bool InteractionMsg::has_dest_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void InteractionMsg::clear_dest_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dest_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t InteractionMsg::dest_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.InteractionMsg.dest_id)
  return _internal_dest_id();
}
inline void InteractionMsg::set_dest_id(::uint32_t value) {
  _internal_set_dest_id(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.InteractionMsg.dest_id)
}
inline ::uint32_t InteractionMsg::_internal_dest_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dest_id_;
}
inline void InteractionMsg::_internal_set_dest_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dest_id_ = value;
}

// string dest_name = 6;
inline bool InteractionMsg::has_dest_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InteractionMsg::clear_dest_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dest_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InteractionMsg::dest_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.InteractionMsg.dest_name)
  return _internal_dest_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InteractionMsg::set_dest_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dest_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.InteractionMsg.dest_name)
}
inline std::string* InteractionMsg::mutable_dest_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dest_name();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.InteractionMsg.dest_name)
  return _s;
}
inline const std::string& InteractionMsg::_internal_dest_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dest_name_.Get();
}
inline void InteractionMsg::_internal_set_dest_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dest_name_.Set(value, GetArena());
}
inline std::string* InteractionMsg::_internal_mutable_dest_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dest_name_.Mutable( GetArena());
}
inline std::string* InteractionMsg::release_dest_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.InteractionMsg.dest_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dest_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dest_name_.Set("", GetArena());
  }
  return released;
}
inline void InteractionMsg::set_allocated_dest_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dest_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dest_name_.IsDefault()) {
    _impl_.dest_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.InteractionMsg.dest_name)
}

// .smart_pkg_delivery.Request request = 7;
inline bool InteractionMsg::has_request() const {
  return msg_type_case() == kRequest;
}
inline bool InteractionMsg::_internal_has_request() const {
  return msg_type_case() == kRequest;
}
inline void InteractionMsg::set_has_request() {
  _impl_._oneof_case_[0] = kRequest;
}
inline void InteractionMsg::clear_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_type_case() == kRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_type_.request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_type_.request_);
    }
    clear_has_msg_type();
  }
}
inline ::smart_pkg_delivery::Request* InteractionMsg::release_request() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.InteractionMsg.request)
  if (msg_type_case() == kRequest) {
    clear_has_msg_type();
    auto* temp = _impl_.msg_type_.request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_type_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::Request& InteractionMsg::_internal_request() const {
  return msg_type_case() == kRequest ? *_impl_.msg_type_.request_ : reinterpret_cast<::smart_pkg_delivery::Request&>(::smart_pkg_delivery::_Request_default_instance_);
}
inline const ::smart_pkg_delivery::Request& InteractionMsg::request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.InteractionMsg.request)
  return _internal_request();
}
inline ::smart_pkg_delivery::Request* InteractionMsg::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.InteractionMsg.request)
  if (msg_type_case() == kRequest) {
    clear_has_msg_type();
    auto* temp = _impl_.msg_type_.request_;
    _impl_.msg_type_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InteractionMsg::unsafe_arena_set_allocated_request(::smart_pkg_delivery::Request* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_type();
  if (value) {
    set_has_request();
    _impl_.msg_type_.request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.InteractionMsg.request)
}
inline ::smart_pkg_delivery::Request* InteractionMsg::_internal_mutable_request() {
  if (msg_type_case() != kRequest) {
    clear_msg_type();
    set_has_request();
    _impl_.msg_type_.request_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::Request>(GetArena());
  }
  return _impl_.msg_type_.request_;
}
inline ::smart_pkg_delivery::Request* InteractionMsg::mutable_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.InteractionMsg.request)
  return _msg;
}

// .smart_pkg_delivery.Response response = 8;
inline bool InteractionMsg::has_response() const {
  return msg_type_case() == kResponse;
}
inline bool InteractionMsg::_internal_has_response() const {
  return msg_type_case() == kResponse;
}
inline void InteractionMsg::set_has_response() {
  _impl_._oneof_case_[0] = kResponse;
}
inline void InteractionMsg::clear_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_type_case() == kResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_type_.response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_type_.response_);
    }
    clear_has_msg_type();
  }
}
inline ::smart_pkg_delivery::Response* InteractionMsg::release_response() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.InteractionMsg.response)
  if (msg_type_case() == kResponse) {
    clear_has_msg_type();
    auto* temp = _impl_.msg_type_.response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_type_.response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::Response& InteractionMsg::_internal_response() const {
  return msg_type_case() == kResponse ? *_impl_.msg_type_.response_ : reinterpret_cast<::smart_pkg_delivery::Response&>(::smart_pkg_delivery::_Response_default_instance_);
}
inline const ::smart_pkg_delivery::Response& InteractionMsg::response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.InteractionMsg.response)
  return _internal_response();
}
inline ::smart_pkg_delivery::Response* InteractionMsg::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.InteractionMsg.response)
  if (msg_type_case() == kResponse) {
    clear_has_msg_type();
    auto* temp = _impl_.msg_type_.response_;
    _impl_.msg_type_.response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InteractionMsg::unsafe_arena_set_allocated_response(::smart_pkg_delivery::Response* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_type();
  if (value) {
    set_has_response();
    _impl_.msg_type_.response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.InteractionMsg.response)
}
inline ::smart_pkg_delivery::Response* InteractionMsg::_internal_mutable_response() {
  if (msg_type_case() != kResponse) {
    clear_msg_type();
    set_has_response();
    _impl_.msg_type_.response_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::Response>(GetArena());
  }
  return _impl_.msg_type_.response_;
}
inline ::smart_pkg_delivery::Response* InteractionMsg::mutable_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.InteractionMsg.response)
  return _msg;
}

// .smart_pkg_delivery.NodeEvent node_event = 9;
inline bool InteractionMsg::has_node_event() const {
  return msg_type_case() == kNodeEvent;
}
inline bool InteractionMsg::_internal_has_node_event() const {
  return msg_type_case() == kNodeEvent;
}
inline void InteractionMsg::set_has_node_event() {
  _impl_._oneof_case_[0] = kNodeEvent;
}
inline void InteractionMsg::clear_node_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_type_case() == kNodeEvent) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_type_.node_event_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_type_.node_event_);
    }
    clear_has_msg_type();
  }
}
inline ::smart_pkg_delivery::NodeEvent* InteractionMsg::release_node_event() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.InteractionMsg.node_event)
  if (msg_type_case() == kNodeEvent) {
    clear_has_msg_type();
    auto* temp = _impl_.msg_type_.node_event_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_type_.node_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::NodeEvent& InteractionMsg::_internal_node_event() const {
  return msg_type_case() == kNodeEvent ? *_impl_.msg_type_.node_event_ : reinterpret_cast<::smart_pkg_delivery::NodeEvent&>(::smart_pkg_delivery::_NodeEvent_default_instance_);
}
inline const ::smart_pkg_delivery::NodeEvent& InteractionMsg::node_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.InteractionMsg.node_event)
  return _internal_node_event();
}
inline ::smart_pkg_delivery::NodeEvent* InteractionMsg::unsafe_arena_release_node_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.InteractionMsg.node_event)
  if (msg_type_case() == kNodeEvent) {
    clear_has_msg_type();
    auto* temp = _impl_.msg_type_.node_event_;
    _impl_.msg_type_.node_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InteractionMsg::unsafe_arena_set_allocated_node_event(::smart_pkg_delivery::NodeEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_type();
  if (value) {
    set_has_node_event();
    _impl_.msg_type_.node_event_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.InteractionMsg.node_event)
}
inline ::smart_pkg_delivery::NodeEvent* InteractionMsg::_internal_mutable_node_event() {
  if (msg_type_case() != kNodeEvent) {
    clear_msg_type();
    set_has_node_event();
    _impl_.msg_type_.node_event_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::NodeEvent>(GetArena());
  }
  return _impl_.msg_type_.node_event_;
}
inline ::smart_pkg_delivery::NodeEvent* InteractionMsg::mutable_node_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::NodeEvent* _msg = _internal_mutable_node_event();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.InteractionMsg.node_event)
  return _msg;
}

inline bool InteractionMsg::has_msg_type() const {
  return msg_type_case() != MSG_TYPE_NOT_SET;
}
inline void InteractionMsg::clear_has_msg_type() {
  _impl_._oneof_case_[0] = MSG_TYPE_NOT_SET;
}
inline InteractionMsg::MsgTypeCase InteractionMsg::msg_type_case() const {
  return InteractionMsg::MsgTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Request

// .smart_pkg_delivery.ClientRegisterRequest client_register_request = 1;
inline bool Request::has_client_register_request() const {
  return request_type_case() == kClientRegisterRequest;
}
inline bool Request::_internal_has_client_register_request() const {
  return request_type_case() == kClientRegisterRequest;
}
inline void Request::set_has_client_register_request() {
  _impl_._oneof_case_[0] = kClientRegisterRequest;
}
inline void Request::clear_client_register_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_type_case() == kClientRegisterRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.request_type_.client_register_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_type_.client_register_request_);
    }
    clear_has_request_type();
  }
}
inline ::smart_pkg_delivery::ClientRegisterRequest* Request::release_client_register_request() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Request.client_register_request)
  if (request_type_case() == kClientRegisterRequest) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.client_register_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.client_register_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::ClientRegisterRequest& Request::_internal_client_register_request() const {
  return request_type_case() == kClientRegisterRequest ? *_impl_.request_type_.client_register_request_ : reinterpret_cast<::smart_pkg_delivery::ClientRegisterRequest&>(::smart_pkg_delivery::_ClientRegisterRequest_default_instance_);
}
inline const ::smart_pkg_delivery::ClientRegisterRequest& Request::client_register_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Request.client_register_request)
  return _internal_client_register_request();
}
inline ::smart_pkg_delivery::ClientRegisterRequest* Request::unsafe_arena_release_client_register_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.Request.client_register_request)
  if (request_type_case() == kClientRegisterRequest) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.client_register_request_;
    _impl_.request_type_.client_register_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_client_register_request(::smart_pkg_delivery::ClientRegisterRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_client_register_request();
    _impl_.request_type_.client_register_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Request.client_register_request)
}
inline ::smart_pkg_delivery::ClientRegisterRequest* Request::_internal_mutable_client_register_request() {
  if (request_type_case() != kClientRegisterRequest) {
    clear_request_type();
    set_has_client_register_request();
    _impl_.request_type_.client_register_request_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::ClientRegisterRequest>(GetArena());
  }
  return _impl_.request_type_.client_register_request_;
}
inline ::smart_pkg_delivery::ClientRegisterRequest* Request::mutable_client_register_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::ClientRegisterRequest* _msg = _internal_mutable_client_register_request();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Request.client_register_request)
  return _msg;
}

// .smart_pkg_delivery.GetPkgInfosRequest get_pkg_infos_request = 2;
inline bool Request::has_get_pkg_infos_request() const {
  return request_type_case() == kGetPkgInfosRequest;
}
inline bool Request::_internal_has_get_pkg_infos_request() const {
  return request_type_case() == kGetPkgInfosRequest;
}
inline void Request::set_has_get_pkg_infos_request() {
  _impl_._oneof_case_[0] = kGetPkgInfosRequest;
}
inline void Request::clear_get_pkg_infos_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_type_case() == kGetPkgInfosRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.request_type_.get_pkg_infos_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_type_.get_pkg_infos_request_);
    }
    clear_has_request_type();
  }
}
inline ::smart_pkg_delivery::GetPkgInfosRequest* Request::release_get_pkg_infos_request() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Request.get_pkg_infos_request)
  if (request_type_case() == kGetPkgInfosRequest) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.get_pkg_infos_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.get_pkg_infos_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::GetPkgInfosRequest& Request::_internal_get_pkg_infos_request() const {
  return request_type_case() == kGetPkgInfosRequest ? *_impl_.request_type_.get_pkg_infos_request_ : reinterpret_cast<::smart_pkg_delivery::GetPkgInfosRequest&>(::smart_pkg_delivery::_GetPkgInfosRequest_default_instance_);
}
inline const ::smart_pkg_delivery::GetPkgInfosRequest& Request::get_pkg_infos_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Request.get_pkg_infos_request)
  return _internal_get_pkg_infos_request();
}
inline ::smart_pkg_delivery::GetPkgInfosRequest* Request::unsafe_arena_release_get_pkg_infos_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.Request.get_pkg_infos_request)
  if (request_type_case() == kGetPkgInfosRequest) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.get_pkg_infos_request_;
    _impl_.request_type_.get_pkg_infos_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_get_pkg_infos_request(::smart_pkg_delivery::GetPkgInfosRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_get_pkg_infos_request();
    _impl_.request_type_.get_pkg_infos_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Request.get_pkg_infos_request)
}
inline ::smart_pkg_delivery::GetPkgInfosRequest* Request::_internal_mutable_get_pkg_infos_request() {
  if (request_type_case() != kGetPkgInfosRequest) {
    clear_request_type();
    set_has_get_pkg_infos_request();
    _impl_.request_type_.get_pkg_infos_request_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::GetPkgInfosRequest>(GetArena());
  }
  return _impl_.request_type_.get_pkg_infos_request_;
}
inline ::smart_pkg_delivery::GetPkgInfosRequest* Request::mutable_get_pkg_infos_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::GetPkgInfosRequest* _msg = _internal_mutable_get_pkg_infos_request();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Request.get_pkg_infos_request)
  return _msg;
}

// .smart_pkg_delivery.SetElevatorStatusRequest set_elevator_status_request = 3;
inline bool Request::has_set_elevator_status_request() const {
  return request_type_case() == kSetElevatorStatusRequest;
}
inline bool Request::_internal_has_set_elevator_status_request() const {
  return request_type_case() == kSetElevatorStatusRequest;
}
inline void Request::set_has_set_elevator_status_request() {
  _impl_._oneof_case_[0] = kSetElevatorStatusRequest;
}
inline void Request::clear_set_elevator_status_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_type_case() == kSetElevatorStatusRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.request_type_.set_elevator_status_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_type_.set_elevator_status_request_);
    }
    clear_has_request_type();
  }
}
inline ::smart_pkg_delivery::SetElevatorStatusRequest* Request::release_set_elevator_status_request() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Request.set_elevator_status_request)
  if (request_type_case() == kSetElevatorStatusRequest) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.set_elevator_status_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.set_elevator_status_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::SetElevatorStatusRequest& Request::_internal_set_elevator_status_request() const {
  return request_type_case() == kSetElevatorStatusRequest ? *_impl_.request_type_.set_elevator_status_request_ : reinterpret_cast<::smart_pkg_delivery::SetElevatorStatusRequest&>(::smart_pkg_delivery::_SetElevatorStatusRequest_default_instance_);
}
inline const ::smart_pkg_delivery::SetElevatorStatusRequest& Request::set_elevator_status_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Request.set_elevator_status_request)
  return _internal_set_elevator_status_request();
}
inline ::smart_pkg_delivery::SetElevatorStatusRequest* Request::unsafe_arena_release_set_elevator_status_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.Request.set_elevator_status_request)
  if (request_type_case() == kSetElevatorStatusRequest) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.set_elevator_status_request_;
    _impl_.request_type_.set_elevator_status_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_set_elevator_status_request(::smart_pkg_delivery::SetElevatorStatusRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_set_elevator_status_request();
    _impl_.request_type_.set_elevator_status_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Request.set_elevator_status_request)
}
inline ::smart_pkg_delivery::SetElevatorStatusRequest* Request::_internal_mutable_set_elevator_status_request() {
  if (request_type_case() != kSetElevatorStatusRequest) {
    clear_request_type();
    set_has_set_elevator_status_request();
    _impl_.request_type_.set_elevator_status_request_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::SetElevatorStatusRequest>(GetArena());
  }
  return _impl_.request_type_.set_elevator_status_request_;
}
inline ::smart_pkg_delivery::SetElevatorStatusRequest* Request::mutable_set_elevator_status_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::SetElevatorStatusRequest* _msg = _internal_mutable_set_elevator_status_request();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Request.set_elevator_status_request)
  return _msg;
}

// .smart_pkg_delivery.MoveDeliveryRobotRequest move_delivery_robot_request = 4;
inline bool Request::has_move_delivery_robot_request() const {
  return request_type_case() == kMoveDeliveryRobotRequest;
}
inline bool Request::_internal_has_move_delivery_robot_request() const {
  return request_type_case() == kMoveDeliveryRobotRequest;
}
inline void Request::set_has_move_delivery_robot_request() {
  _impl_._oneof_case_[0] = kMoveDeliveryRobotRequest;
}
inline void Request::clear_move_delivery_robot_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_type_case() == kMoveDeliveryRobotRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.request_type_.move_delivery_robot_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_type_.move_delivery_robot_request_);
    }
    clear_has_request_type();
  }
}
inline ::smart_pkg_delivery::MoveDeliveryRobotRequest* Request::release_move_delivery_robot_request() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Request.move_delivery_robot_request)
  if (request_type_case() == kMoveDeliveryRobotRequest) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.move_delivery_robot_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.move_delivery_robot_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::MoveDeliveryRobotRequest& Request::_internal_move_delivery_robot_request() const {
  return request_type_case() == kMoveDeliveryRobotRequest ? *_impl_.request_type_.move_delivery_robot_request_ : reinterpret_cast<::smart_pkg_delivery::MoveDeliveryRobotRequest&>(::smart_pkg_delivery::_MoveDeliveryRobotRequest_default_instance_);
}
inline const ::smart_pkg_delivery::MoveDeliveryRobotRequest& Request::move_delivery_robot_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Request.move_delivery_robot_request)
  return _internal_move_delivery_robot_request();
}
inline ::smart_pkg_delivery::MoveDeliveryRobotRequest* Request::unsafe_arena_release_move_delivery_robot_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.Request.move_delivery_robot_request)
  if (request_type_case() == kMoveDeliveryRobotRequest) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.move_delivery_robot_request_;
    _impl_.request_type_.move_delivery_robot_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_move_delivery_robot_request(::smart_pkg_delivery::MoveDeliveryRobotRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_move_delivery_robot_request();
    _impl_.request_type_.move_delivery_robot_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Request.move_delivery_robot_request)
}
inline ::smart_pkg_delivery::MoveDeliveryRobotRequest* Request::_internal_mutable_move_delivery_robot_request() {
  if (request_type_case() != kMoveDeliveryRobotRequest) {
    clear_request_type();
    set_has_move_delivery_robot_request();
    _impl_.request_type_.move_delivery_robot_request_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::MoveDeliveryRobotRequest>(GetArena());
  }
  return _impl_.request_type_.move_delivery_robot_request_;
}
inline ::smart_pkg_delivery::MoveDeliveryRobotRequest* Request::mutable_move_delivery_robot_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::MoveDeliveryRobotRequest* _msg = _internal_mutable_move_delivery_robot_request();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Request.move_delivery_robot_request)
  return _msg;
}

inline bool Request::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void Request::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline Request::RequestTypeCase Request::request_type_case() const {
  return Request::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .smart_pkg_delivery.AckStatus ack_status = 1;
inline bool Response::has_ack_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ack_status_ != nullptr);
  return value;
}
inline void Response::clear_ack_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ack_status_ != nullptr) _impl_.ack_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::smart_pkg_delivery::AckStatus& Response::_internal_ack_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::smart_pkg_delivery::AckStatus* p = _impl_.ack_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::smart_pkg_delivery::AckStatus&>(::smart_pkg_delivery::_AckStatus_default_instance_);
}
inline const ::smart_pkg_delivery::AckStatus& Response::ack_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Response.ack_status)
  return _internal_ack_status();
}
inline void Response::unsafe_arena_set_allocated_ack_status(::smart_pkg_delivery::AckStatus* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ack_status_);
  }
  _impl_.ack_status_ = reinterpret_cast<::smart_pkg_delivery::AckStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Response.ack_status)
}
inline ::smart_pkg_delivery::AckStatus* Response::release_ack_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::AckStatus* released = _impl_.ack_status_;
  _impl_.ack_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::smart_pkg_delivery::AckStatus* Response::unsafe_arena_release_ack_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Response.ack_status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::AckStatus* temp = _impl_.ack_status_;
  _impl_.ack_status_ = nullptr;
  return temp;
}
inline ::smart_pkg_delivery::AckStatus* Response::_internal_mutable_ack_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ack_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::AckStatus>(GetArena());
    _impl_.ack_status_ = reinterpret_cast<::smart_pkg_delivery::AckStatus*>(p);
  }
  return _impl_.ack_status_;
}
inline ::smart_pkg_delivery::AckStatus* Response::mutable_ack_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::smart_pkg_delivery::AckStatus* _msg = _internal_mutable_ack_status();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Response.ack_status)
  return _msg;
}
inline void Response::set_allocated_ack_status(::smart_pkg_delivery::AckStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.ack_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ack_status_ = reinterpret_cast<::smart_pkg_delivery::AckStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.Response.ack_status)
}

// .smart_pkg_delivery.ExecutionStatus execution_status = 2;
inline bool Response::has_execution_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.execution_status_ != nullptr);
  return value;
}
inline void Response::clear_execution_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.execution_status_ != nullptr) _impl_.execution_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::smart_pkg_delivery::ExecutionStatus& Response::_internal_execution_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::smart_pkg_delivery::ExecutionStatus* p = _impl_.execution_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::smart_pkg_delivery::ExecutionStatus&>(::smart_pkg_delivery::_ExecutionStatus_default_instance_);
}
inline const ::smart_pkg_delivery::ExecutionStatus& Response::execution_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Response.execution_status)
  return _internal_execution_status();
}
inline void Response::unsafe_arena_set_allocated_execution_status(::smart_pkg_delivery::ExecutionStatus* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.execution_status_);
  }
  _impl_.execution_status_ = reinterpret_cast<::smart_pkg_delivery::ExecutionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Response.execution_status)
}
inline ::smart_pkg_delivery::ExecutionStatus* Response::release_execution_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::smart_pkg_delivery::ExecutionStatus* released = _impl_.execution_status_;
  _impl_.execution_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::smart_pkg_delivery::ExecutionStatus* Response::unsafe_arena_release_execution_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Response.execution_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::smart_pkg_delivery::ExecutionStatus* temp = _impl_.execution_status_;
  _impl_.execution_status_ = nullptr;
  return temp;
}
inline ::smart_pkg_delivery::ExecutionStatus* Response::_internal_mutable_execution_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.execution_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::ExecutionStatus>(GetArena());
    _impl_.execution_status_ = reinterpret_cast<::smart_pkg_delivery::ExecutionStatus*>(p);
  }
  return _impl_.execution_status_;
}
inline ::smart_pkg_delivery::ExecutionStatus* Response::mutable_execution_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::smart_pkg_delivery::ExecutionStatus* _msg = _internal_mutable_execution_status();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Response.execution_status)
  return _msg;
}
inline void Response::set_allocated_execution_status(::smart_pkg_delivery::ExecutionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.execution_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.execution_status_ = reinterpret_cast<::smart_pkg_delivery::ExecutionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.Response.execution_status)
}

// .smart_pkg_delivery.ClientRegisterResponse client_register_response = 3;
inline bool Response::has_client_register_response() const {
  return response_type_case() == kClientRegisterResponse;
}
inline bool Response::_internal_has_client_register_response() const {
  return response_type_case() == kClientRegisterResponse;
}
inline void Response::set_has_client_register_response() {
  _impl_._oneof_case_[0] = kClientRegisterResponse;
}
inline void Response::clear_client_register_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_type_case() == kClientRegisterResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_type_.client_register_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_type_.client_register_response_);
    }
    clear_has_response_type();
  }
}
inline ::smart_pkg_delivery::ClientRegisterResponse* Response::release_client_register_response() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Response.client_register_response)
  if (response_type_case() == kClientRegisterResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.client_register_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.client_register_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::ClientRegisterResponse& Response::_internal_client_register_response() const {
  return response_type_case() == kClientRegisterResponse ? *_impl_.response_type_.client_register_response_ : reinterpret_cast<::smart_pkg_delivery::ClientRegisterResponse&>(::smart_pkg_delivery::_ClientRegisterResponse_default_instance_);
}
inline const ::smart_pkg_delivery::ClientRegisterResponse& Response::client_register_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Response.client_register_response)
  return _internal_client_register_response();
}
inline ::smart_pkg_delivery::ClientRegisterResponse* Response::unsafe_arena_release_client_register_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.Response.client_register_response)
  if (response_type_case() == kClientRegisterResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.client_register_response_;
    _impl_.response_type_.client_register_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_client_register_response(::smart_pkg_delivery::ClientRegisterResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_client_register_response();
    _impl_.response_type_.client_register_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Response.client_register_response)
}
inline ::smart_pkg_delivery::ClientRegisterResponse* Response::_internal_mutable_client_register_response() {
  if (response_type_case() != kClientRegisterResponse) {
    clear_response_type();
    set_has_client_register_response();
    _impl_.response_type_.client_register_response_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::ClientRegisterResponse>(GetArena());
  }
  return _impl_.response_type_.client_register_response_;
}
inline ::smart_pkg_delivery::ClientRegisterResponse* Response::mutable_client_register_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::ClientRegisterResponse* _msg = _internal_mutable_client_register_response();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Response.client_register_response)
  return _msg;
}

// .smart_pkg_delivery.GetPkgInfoResponse get_pkg_info_response = 4;
inline bool Response::has_get_pkg_info_response() const {
  return response_type_case() == kGetPkgInfoResponse;
}
inline bool Response::_internal_has_get_pkg_info_response() const {
  return response_type_case() == kGetPkgInfoResponse;
}
inline void Response::set_has_get_pkg_info_response() {
  _impl_._oneof_case_[0] = kGetPkgInfoResponse;
}
inline void Response::clear_get_pkg_info_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_type_case() == kGetPkgInfoResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_type_.get_pkg_info_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_type_.get_pkg_info_response_);
    }
    clear_has_response_type();
  }
}
inline ::smart_pkg_delivery::GetPkgInfoResponse* Response::release_get_pkg_info_response() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Response.get_pkg_info_response)
  if (response_type_case() == kGetPkgInfoResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.get_pkg_info_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.get_pkg_info_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::GetPkgInfoResponse& Response::_internal_get_pkg_info_response() const {
  return response_type_case() == kGetPkgInfoResponse ? *_impl_.response_type_.get_pkg_info_response_ : reinterpret_cast<::smart_pkg_delivery::GetPkgInfoResponse&>(::smart_pkg_delivery::_GetPkgInfoResponse_default_instance_);
}
inline const ::smart_pkg_delivery::GetPkgInfoResponse& Response::get_pkg_info_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Response.get_pkg_info_response)
  return _internal_get_pkg_info_response();
}
inline ::smart_pkg_delivery::GetPkgInfoResponse* Response::unsafe_arena_release_get_pkg_info_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.Response.get_pkg_info_response)
  if (response_type_case() == kGetPkgInfoResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.get_pkg_info_response_;
    _impl_.response_type_.get_pkg_info_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_get_pkg_info_response(::smart_pkg_delivery::GetPkgInfoResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_get_pkg_info_response();
    _impl_.response_type_.get_pkg_info_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Response.get_pkg_info_response)
}
inline ::smart_pkg_delivery::GetPkgInfoResponse* Response::_internal_mutable_get_pkg_info_response() {
  if (response_type_case() != kGetPkgInfoResponse) {
    clear_response_type();
    set_has_get_pkg_info_response();
    _impl_.response_type_.get_pkg_info_response_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::GetPkgInfoResponse>(GetArena());
  }
  return _impl_.response_type_.get_pkg_info_response_;
}
inline ::smart_pkg_delivery::GetPkgInfoResponse* Response::mutable_get_pkg_info_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::GetPkgInfoResponse* _msg = _internal_mutable_get_pkg_info_response();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Response.get_pkg_info_response)
  return _msg;
}

// .smart_pkg_delivery.SetElevatorStatusResponse set_elevator_status_response = 5;
inline bool Response::has_set_elevator_status_response() const {
  return response_type_case() == kSetElevatorStatusResponse;
}
inline bool Response::_internal_has_set_elevator_status_response() const {
  return response_type_case() == kSetElevatorStatusResponse;
}
inline void Response::set_has_set_elevator_status_response() {
  _impl_._oneof_case_[0] = kSetElevatorStatusResponse;
}
inline void Response::clear_set_elevator_status_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_type_case() == kSetElevatorStatusResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_type_.set_elevator_status_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_type_.set_elevator_status_response_);
    }
    clear_has_response_type();
  }
}
inline ::smart_pkg_delivery::SetElevatorStatusResponse* Response::release_set_elevator_status_response() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Response.set_elevator_status_response)
  if (response_type_case() == kSetElevatorStatusResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.set_elevator_status_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.set_elevator_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::SetElevatorStatusResponse& Response::_internal_set_elevator_status_response() const {
  return response_type_case() == kSetElevatorStatusResponse ? *_impl_.response_type_.set_elevator_status_response_ : reinterpret_cast<::smart_pkg_delivery::SetElevatorStatusResponse&>(::smart_pkg_delivery::_SetElevatorStatusResponse_default_instance_);
}
inline const ::smart_pkg_delivery::SetElevatorStatusResponse& Response::set_elevator_status_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Response.set_elevator_status_response)
  return _internal_set_elevator_status_response();
}
inline ::smart_pkg_delivery::SetElevatorStatusResponse* Response::unsafe_arena_release_set_elevator_status_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.Response.set_elevator_status_response)
  if (response_type_case() == kSetElevatorStatusResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.set_elevator_status_response_;
    _impl_.response_type_.set_elevator_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_set_elevator_status_response(::smart_pkg_delivery::SetElevatorStatusResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_set_elevator_status_response();
    _impl_.response_type_.set_elevator_status_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Response.set_elevator_status_response)
}
inline ::smart_pkg_delivery::SetElevatorStatusResponse* Response::_internal_mutable_set_elevator_status_response() {
  if (response_type_case() != kSetElevatorStatusResponse) {
    clear_response_type();
    set_has_set_elevator_status_response();
    _impl_.response_type_.set_elevator_status_response_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::SetElevatorStatusResponse>(GetArena());
  }
  return _impl_.response_type_.set_elevator_status_response_;
}
inline ::smart_pkg_delivery::SetElevatorStatusResponse* Response::mutable_set_elevator_status_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::SetElevatorStatusResponse* _msg = _internal_mutable_set_elevator_status_response();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Response.set_elevator_status_response)
  return _msg;
}

// .smart_pkg_delivery.MoveDeliveryRobotResponse move_delivery_robot_response = 6;
inline bool Response::has_move_delivery_robot_response() const {
  return response_type_case() == kMoveDeliveryRobotResponse;
}
inline bool Response::_internal_has_move_delivery_robot_response() const {
  return response_type_case() == kMoveDeliveryRobotResponse;
}
inline void Response::set_has_move_delivery_robot_response() {
  _impl_._oneof_case_[0] = kMoveDeliveryRobotResponse;
}
inline void Response::clear_move_delivery_robot_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_type_case() == kMoveDeliveryRobotResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_type_.move_delivery_robot_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_type_.move_delivery_robot_response_);
    }
    clear_has_response_type();
  }
}
inline ::smart_pkg_delivery::MoveDeliveryRobotResponse* Response::release_move_delivery_robot_response() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Response.move_delivery_robot_response)
  if (response_type_case() == kMoveDeliveryRobotResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.move_delivery_robot_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.move_delivery_robot_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::MoveDeliveryRobotResponse& Response::_internal_move_delivery_robot_response() const {
  return response_type_case() == kMoveDeliveryRobotResponse ? *_impl_.response_type_.move_delivery_robot_response_ : reinterpret_cast<::smart_pkg_delivery::MoveDeliveryRobotResponse&>(::smart_pkg_delivery::_MoveDeliveryRobotResponse_default_instance_);
}
inline const ::smart_pkg_delivery::MoveDeliveryRobotResponse& Response::move_delivery_robot_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Response.move_delivery_robot_response)
  return _internal_move_delivery_robot_response();
}
inline ::smart_pkg_delivery::MoveDeliveryRobotResponse* Response::unsafe_arena_release_move_delivery_robot_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.Response.move_delivery_robot_response)
  if (response_type_case() == kMoveDeliveryRobotResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.move_delivery_robot_response_;
    _impl_.response_type_.move_delivery_robot_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_move_delivery_robot_response(::smart_pkg_delivery::MoveDeliveryRobotResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_move_delivery_robot_response();
    _impl_.response_type_.move_delivery_robot_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Response.move_delivery_robot_response)
}
inline ::smart_pkg_delivery::MoveDeliveryRobotResponse* Response::_internal_mutable_move_delivery_robot_response() {
  if (response_type_case() != kMoveDeliveryRobotResponse) {
    clear_response_type();
    set_has_move_delivery_robot_response();
    _impl_.response_type_.move_delivery_robot_response_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::MoveDeliveryRobotResponse>(GetArena());
  }
  return _impl_.response_type_.move_delivery_robot_response_;
}
inline ::smart_pkg_delivery::MoveDeliveryRobotResponse* Response::mutable_move_delivery_robot_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::MoveDeliveryRobotResponse* _msg = _internal_mutable_move_delivery_robot_response();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Response.move_delivery_robot_response)
  return _msg;
}

inline bool Response::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void Response::clear_has_response_type() {
  _impl_._oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline Response::ResponseTypeCase Response::response_type_case() const {
  return Response::ResponseTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NodeEvent

// .smart_pkg_delivery.PkgArrivalEvent pkg_arrival_event = 1;
inline bool NodeEvent::has_pkg_arrival_event() const {
  return event_type_case() == kPkgArrivalEvent;
}
inline bool NodeEvent::_internal_has_pkg_arrival_event() const {
  return event_type_case() == kPkgArrivalEvent;
}
inline void NodeEvent::set_has_pkg_arrival_event() {
  _impl_._oneof_case_[0] = kPkgArrivalEvent;
}
inline void NodeEvent::clear_pkg_arrival_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_type_case() == kPkgArrivalEvent) {
    if (GetArena() == nullptr) {
      delete _impl_.event_type_.pkg_arrival_event_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_type_.pkg_arrival_event_);
    }
    clear_has_event_type();
  }
}
inline ::smart_pkg_delivery::PkgArrivalEvent* NodeEvent::release_pkg_arrival_event() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.NodeEvent.pkg_arrival_event)
  if (event_type_case() == kPkgArrivalEvent) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.pkg_arrival_event_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_type_.pkg_arrival_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::PkgArrivalEvent& NodeEvent::_internal_pkg_arrival_event() const {
  return event_type_case() == kPkgArrivalEvent ? *_impl_.event_type_.pkg_arrival_event_ : reinterpret_cast<::smart_pkg_delivery::PkgArrivalEvent&>(::smart_pkg_delivery::_PkgArrivalEvent_default_instance_);
}
inline const ::smart_pkg_delivery::PkgArrivalEvent& NodeEvent::pkg_arrival_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.NodeEvent.pkg_arrival_event)
  return _internal_pkg_arrival_event();
}
inline ::smart_pkg_delivery::PkgArrivalEvent* NodeEvent::unsafe_arena_release_pkg_arrival_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.NodeEvent.pkg_arrival_event)
  if (event_type_case() == kPkgArrivalEvent) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.pkg_arrival_event_;
    _impl_.event_type_.pkg_arrival_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeEvent::unsafe_arena_set_allocated_pkg_arrival_event(::smart_pkg_delivery::PkgArrivalEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_type();
  if (value) {
    set_has_pkg_arrival_event();
    _impl_.event_type_.pkg_arrival_event_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.NodeEvent.pkg_arrival_event)
}
inline ::smart_pkg_delivery::PkgArrivalEvent* NodeEvent::_internal_mutable_pkg_arrival_event() {
  if (event_type_case() != kPkgArrivalEvent) {
    clear_event_type();
    set_has_pkg_arrival_event();
    _impl_.event_type_.pkg_arrival_event_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::PkgArrivalEvent>(GetArena());
  }
  return _impl_.event_type_.pkg_arrival_event_;
}
inline ::smart_pkg_delivery::PkgArrivalEvent* NodeEvent::mutable_pkg_arrival_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::PkgArrivalEvent* _msg = _internal_mutable_pkg_arrival_event();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.NodeEvent.pkg_arrival_event)
  return _msg;
}

// .smart_pkg_delivery.ElevatorStatusEvent elevator_status_event = 2;
inline bool NodeEvent::has_elevator_status_event() const {
  return event_type_case() == kElevatorStatusEvent;
}
inline bool NodeEvent::_internal_has_elevator_status_event() const {
  return event_type_case() == kElevatorStatusEvent;
}
inline void NodeEvent::set_has_elevator_status_event() {
  _impl_._oneof_case_[0] = kElevatorStatusEvent;
}
inline void NodeEvent::clear_elevator_status_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_type_case() == kElevatorStatusEvent) {
    if (GetArena() == nullptr) {
      delete _impl_.event_type_.elevator_status_event_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_type_.elevator_status_event_);
    }
    clear_has_event_type();
  }
}
inline ::smart_pkg_delivery::ElevatorStatusEvent* NodeEvent::release_elevator_status_event() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.NodeEvent.elevator_status_event)
  if (event_type_case() == kElevatorStatusEvent) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.elevator_status_event_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_type_.elevator_status_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::ElevatorStatusEvent& NodeEvent::_internal_elevator_status_event() const {
  return event_type_case() == kElevatorStatusEvent ? *_impl_.event_type_.elevator_status_event_ : reinterpret_cast<::smart_pkg_delivery::ElevatorStatusEvent&>(::smart_pkg_delivery::_ElevatorStatusEvent_default_instance_);
}
inline const ::smart_pkg_delivery::ElevatorStatusEvent& NodeEvent::elevator_status_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.NodeEvent.elevator_status_event)
  return _internal_elevator_status_event();
}
inline ::smart_pkg_delivery::ElevatorStatusEvent* NodeEvent::unsafe_arena_release_elevator_status_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.NodeEvent.elevator_status_event)
  if (event_type_case() == kElevatorStatusEvent) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.elevator_status_event_;
    _impl_.event_type_.elevator_status_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeEvent::unsafe_arena_set_allocated_elevator_status_event(::smart_pkg_delivery::ElevatorStatusEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_type();
  if (value) {
    set_has_elevator_status_event();
    _impl_.event_type_.elevator_status_event_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.NodeEvent.elevator_status_event)
}
inline ::smart_pkg_delivery::ElevatorStatusEvent* NodeEvent::_internal_mutable_elevator_status_event() {
  if (event_type_case() != kElevatorStatusEvent) {
    clear_event_type();
    set_has_elevator_status_event();
    _impl_.event_type_.elevator_status_event_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::ElevatorStatusEvent>(GetArena());
  }
  return _impl_.event_type_.elevator_status_event_;
}
inline ::smart_pkg_delivery::ElevatorStatusEvent* NodeEvent::mutable_elevator_status_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::ElevatorStatusEvent* _msg = _internal_mutable_elevator_status_event();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.NodeEvent.elevator_status_event)
  return _msg;
}

// .smart_pkg_delivery.DeliveryStatusEvent delivery_status_event = 3;
inline bool NodeEvent::has_delivery_status_event() const {
  return event_type_case() == kDeliveryStatusEvent;
}
inline bool NodeEvent::_internal_has_delivery_status_event() const {
  return event_type_case() == kDeliveryStatusEvent;
}
inline void NodeEvent::set_has_delivery_status_event() {
  _impl_._oneof_case_[0] = kDeliveryStatusEvent;
}
inline void NodeEvent::clear_delivery_status_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_type_case() == kDeliveryStatusEvent) {
    if (GetArena() == nullptr) {
      delete _impl_.event_type_.delivery_status_event_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_type_.delivery_status_event_);
    }
    clear_has_event_type();
  }
}
inline ::smart_pkg_delivery::DeliveryStatusEvent* NodeEvent::release_delivery_status_event() {
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.NodeEvent.delivery_status_event)
  if (event_type_case() == kDeliveryStatusEvent) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.delivery_status_event_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_type_.delivery_status_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::smart_pkg_delivery::DeliveryStatusEvent& NodeEvent::_internal_delivery_status_event() const {
  return event_type_case() == kDeliveryStatusEvent ? *_impl_.event_type_.delivery_status_event_ : reinterpret_cast<::smart_pkg_delivery::DeliveryStatusEvent&>(::smart_pkg_delivery::_DeliveryStatusEvent_default_instance_);
}
inline const ::smart_pkg_delivery::DeliveryStatusEvent& NodeEvent::delivery_status_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.NodeEvent.delivery_status_event)
  return _internal_delivery_status_event();
}
inline ::smart_pkg_delivery::DeliveryStatusEvent* NodeEvent::unsafe_arena_release_delivery_status_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:smart_pkg_delivery.NodeEvent.delivery_status_event)
  if (event_type_case() == kDeliveryStatusEvent) {
    clear_has_event_type();
    auto* temp = _impl_.event_type_.delivery_status_event_;
    _impl_.event_type_.delivery_status_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeEvent::unsafe_arena_set_allocated_delivery_status_event(::smart_pkg_delivery::DeliveryStatusEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_type();
  if (value) {
    set_has_delivery_status_event();
    _impl_.event_type_.delivery_status_event_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.NodeEvent.delivery_status_event)
}
inline ::smart_pkg_delivery::DeliveryStatusEvent* NodeEvent::_internal_mutable_delivery_status_event() {
  if (event_type_case() != kDeliveryStatusEvent) {
    clear_event_type();
    set_has_delivery_status_event();
    _impl_.event_type_.delivery_status_event_ =
        ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::DeliveryStatusEvent>(GetArena());
  }
  return _impl_.event_type_.delivery_status_event_;
}
inline ::smart_pkg_delivery::DeliveryStatusEvent* NodeEvent::mutable_delivery_status_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::smart_pkg_delivery::DeliveryStatusEvent* _msg = _internal_mutable_delivery_status_event();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.NodeEvent.delivery_status_event)
  return _msg;
}

inline bool NodeEvent::has_event_type() const {
  return event_type_case() != EVENT_TYPE_NOT_SET;
}
inline void NodeEvent::clear_has_event_type() {
  _impl_._oneof_case_[0] = EVENT_TYPE_NOT_SET;
}
inline NodeEvent::EventTypeCase NodeEvent::event_type_case() const {
  return NodeEvent::EventTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AckStatus

// .smart_pkg_delivery.AckStatus.StatusCode status_code = 1;
inline bool AckStatus::has_status_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AckStatus::clear_status_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::smart_pkg_delivery::AckStatus_StatusCode AckStatus::status_code() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.AckStatus.status_code)
  return _internal_status_code();
}
inline void AckStatus::set_status_code(::smart_pkg_delivery::AckStatus_StatusCode value) {
  _internal_set_status_code(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.AckStatus.status_code)
}
inline ::smart_pkg_delivery::AckStatus_StatusCode AckStatus::_internal_status_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::smart_pkg_delivery::AckStatus_StatusCode>(_impl_.status_code_);
}
inline void AckStatus::_internal_set_status_code(::smart_pkg_delivery::AckStatus_StatusCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_code_ = value;
}

// string message = 2;
inline bool AckStatus::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AckStatus::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AckStatus::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.AckStatus.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AckStatus::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.AckStatus.message)
}
inline std::string* AckStatus::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.AckStatus.message)
  return _s;
}
inline const std::string& AckStatus::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void AckStatus::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* AckStatus::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* AckStatus::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.AckStatus.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void AckStatus::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.AckStatus.message)
}

// -------------------------------------------------------------------

// ExecutionStatus

// .smart_pkg_delivery.ExecutionStatus.StatusCode status_code = 1;
inline bool ExecutionStatus::has_status_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ExecutionStatus::clear_status_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::smart_pkg_delivery::ExecutionStatus_StatusCode ExecutionStatus::status_code() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.ExecutionStatus.status_code)
  return _internal_status_code();
}
inline void ExecutionStatus::set_status_code(::smart_pkg_delivery::ExecutionStatus_StatusCode value) {
  _internal_set_status_code(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.ExecutionStatus.status_code)
}
inline ::smart_pkg_delivery::ExecutionStatus_StatusCode ExecutionStatus::_internal_status_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::smart_pkg_delivery::ExecutionStatus_StatusCode>(_impl_.status_code_);
}
inline void ExecutionStatus::_internal_set_status_code(::smart_pkg_delivery::ExecutionStatus_StatusCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_code_ = value;
}

// string message = 2;
inline bool ExecutionStatus::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ExecutionStatus::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExecutionStatus::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.ExecutionStatus.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecutionStatus::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.ExecutionStatus.message)
}
inline std::string* ExecutionStatus::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.ExecutionStatus.message)
  return _s;
}
inline const std::string& ExecutionStatus::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void ExecutionStatus::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ExecutionStatus::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ExecutionStatus::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.ExecutionStatus.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void ExecutionStatus::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.ExecutionStatus.message)
}

// -------------------------------------------------------------------

// ClientRegisterRequest

// .smart_pkg_delivery.NodeType identity_type = 1;
inline bool ClientRegisterRequest::has_identity_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ClientRegisterRequest::clear_identity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identity_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::smart_pkg_delivery::NodeType ClientRegisterRequest::identity_type() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.ClientRegisterRequest.identity_type)
  return _internal_identity_type();
}
inline void ClientRegisterRequest::set_identity_type(::smart_pkg_delivery::NodeType value) {
  _internal_set_identity_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.ClientRegisterRequest.identity_type)
}
inline ::smart_pkg_delivery::NodeType ClientRegisterRequest::_internal_identity_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::smart_pkg_delivery::NodeType>(_impl_.identity_type_);
}
inline void ClientRegisterRequest::_internal_set_identity_type(::smart_pkg_delivery::NodeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identity_type_ = value;
}

// uint32 identity_id = 2;
inline bool ClientRegisterRequest::has_identity_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ClientRegisterRequest::clear_identity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identity_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t ClientRegisterRequest::identity_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.ClientRegisterRequest.identity_id)
  return _internal_identity_id();
}
inline void ClientRegisterRequest::set_identity_id(::uint32_t value) {
  _internal_set_identity_id(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.ClientRegisterRequest.identity_id)
}
inline ::uint32_t ClientRegisterRequest::_internal_identity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.identity_id_;
}
inline void ClientRegisterRequest::_internal_set_identity_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identity_id_ = value;
}

// string identity_name = 3;
inline bool ClientRegisterRequest::has_identity_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ClientRegisterRequest::clear_identity_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identity_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientRegisterRequest::identity_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.ClientRegisterRequest.identity_name)
  return _internal_identity_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientRegisterRequest::set_identity_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.identity_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.ClientRegisterRequest.identity_name)
}
inline std::string* ClientRegisterRequest::mutable_identity_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_identity_name();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.ClientRegisterRequest.identity_name)
  return _s;
}
inline const std::string& ClientRegisterRequest::_internal_identity_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.identity_name_.Get();
}
inline void ClientRegisterRequest::_internal_set_identity_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.identity_name_.Set(value, GetArena());
}
inline std::string* ClientRegisterRequest::_internal_mutable_identity_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.identity_name_.Mutable( GetArena());
}
inline std::string* ClientRegisterRequest::release_identity_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.ClientRegisterRequest.identity_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.identity_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.identity_name_.Set("", GetArena());
  }
  return released;
}
inline void ClientRegisterRequest::set_allocated_identity_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.identity_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.identity_name_.IsDefault()) {
    _impl_.identity_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.ClientRegisterRequest.identity_name)
}

// -------------------------------------------------------------------

// ClientRegisterResponse

// -------------------------------------------------------------------

// GetPkgInfosRequest

// uint32 user_id = 1;
inline bool GetPkgInfosRequest::has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetPkgInfosRequest::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t GetPkgInfosRequest::user_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.GetPkgInfosRequest.user_id)
  return _internal_user_id();
}
inline void GetPkgInfosRequest::set_user_id(::uint32_t value) {
  _internal_set_user_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.GetPkgInfosRequest.user_id)
}
inline ::uint32_t GetPkgInfosRequest::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_;
}
inline void GetPkgInfosRequest::_internal_set_user_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = value;
}

// -------------------------------------------------------------------

// GetPkgInfoResponse

// repeated .smart_pkg_delivery.Pkg pkgs = 1;
inline int GetPkgInfoResponse::_internal_pkgs_size() const {
  return _internal_pkgs().size();
}
inline int GetPkgInfoResponse::pkgs_size() const {
  return _internal_pkgs_size();
}
inline void GetPkgInfoResponse::clear_pkgs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pkgs_.Clear();
}
inline ::smart_pkg_delivery::Pkg* GetPkgInfoResponse::mutable_pkgs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.GetPkgInfoResponse.pkgs)
  return _internal_mutable_pkgs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::Pkg>* GetPkgInfoResponse::mutable_pkgs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:smart_pkg_delivery.GetPkgInfoResponse.pkgs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_pkgs();
}
inline const ::smart_pkg_delivery::Pkg& GetPkgInfoResponse::pkgs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.GetPkgInfoResponse.pkgs)
  return _internal_pkgs().Get(index);
}
inline ::smart_pkg_delivery::Pkg* GetPkgInfoResponse::add_pkgs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::smart_pkg_delivery::Pkg* _add = _internal_mutable_pkgs()->Add();
  // @@protoc_insertion_point(field_add:smart_pkg_delivery.GetPkgInfoResponse.pkgs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::Pkg>& GetPkgInfoResponse::pkgs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:smart_pkg_delivery.GetPkgInfoResponse.pkgs)
  return _internal_pkgs();
}
inline const ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::Pkg>&
GetPkgInfoResponse::_internal_pkgs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pkgs_;
}
inline ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::Pkg>*
GetPkgInfoResponse::_internal_mutable_pkgs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.pkgs_;
}

// -------------------------------------------------------------------

// MoveDeliveryRobotRequest

// uint32 delivery_robot_id = 1;
inline bool MoveDeliveryRobotRequest::has_delivery_robot_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MoveDeliveryRobotRequest::clear_delivery_robot_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delivery_robot_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t MoveDeliveryRobotRequest::delivery_robot_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.MoveDeliveryRobotRequest.delivery_robot_id)
  return _internal_delivery_robot_id();
}
inline void MoveDeliveryRobotRequest::set_delivery_robot_id(::uint32_t value) {
  _internal_set_delivery_robot_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.MoveDeliveryRobotRequest.delivery_robot_id)
}
inline ::uint32_t MoveDeliveryRobotRequest::_internal_delivery_robot_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delivery_robot_id_;
}
inline void MoveDeliveryRobotRequest::_internal_set_delivery_robot_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delivery_robot_id_ = value;
}

// .smart_pkg_delivery.AptAddress destination_address = 2;
inline bool MoveDeliveryRobotRequest::has_destination_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.destination_address_ != nullptr);
  return value;
}
inline void MoveDeliveryRobotRequest::clear_destination_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.destination_address_ != nullptr) _impl_.destination_address_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::smart_pkg_delivery::AptAddress& MoveDeliveryRobotRequest::_internal_destination_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::smart_pkg_delivery::AptAddress* p = _impl_.destination_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::smart_pkg_delivery::AptAddress&>(::smart_pkg_delivery::_AptAddress_default_instance_);
}
inline const ::smart_pkg_delivery::AptAddress& MoveDeliveryRobotRequest::destination_address() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.MoveDeliveryRobotRequest.destination_address)
  return _internal_destination_address();
}
inline void MoveDeliveryRobotRequest::unsafe_arena_set_allocated_destination_address(::smart_pkg_delivery::AptAddress* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_address_);
  }
  _impl_.destination_address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.MoveDeliveryRobotRequest.destination_address)
}
inline ::smart_pkg_delivery::AptAddress* MoveDeliveryRobotRequest::release_destination_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::AptAddress* released = _impl_.destination_address_;
  _impl_.destination_address_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::smart_pkg_delivery::AptAddress* MoveDeliveryRobotRequest::unsafe_arena_release_destination_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.MoveDeliveryRobotRequest.destination_address)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::AptAddress* temp = _impl_.destination_address_;
  _impl_.destination_address_ = nullptr;
  return temp;
}
inline ::smart_pkg_delivery::AptAddress* MoveDeliveryRobotRequest::_internal_mutable_destination_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.destination_address_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::AptAddress>(GetArena());
    _impl_.destination_address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(p);
  }
  return _impl_.destination_address_;
}
inline ::smart_pkg_delivery::AptAddress* MoveDeliveryRobotRequest::mutable_destination_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::smart_pkg_delivery::AptAddress* _msg = _internal_mutable_destination_address();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.MoveDeliveryRobotRequest.destination_address)
  return _msg;
}
inline void MoveDeliveryRobotRequest::set_allocated_destination_address(::smart_pkg_delivery::AptAddress* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.destination_address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.destination_address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(value);
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.MoveDeliveryRobotRequest.destination_address)
}

// -------------------------------------------------------------------

// MoveDeliveryRobotResponse

// -------------------------------------------------------------------

// SetElevatorStatusRequest

// uint32 elevator_id = 1;
inline bool SetElevatorStatusRequest::has_elevator_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SetElevatorStatusRequest::clear_elevator_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elevator_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t SetElevatorStatusRequest::elevator_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.SetElevatorStatusRequest.elevator_id)
  return _internal_elevator_id();
}
inline void SetElevatorStatusRequest::set_elevator_id(::uint32_t value) {
  _internal_set_elevator_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.SetElevatorStatusRequest.elevator_id)
}
inline ::uint32_t SetElevatorStatusRequest::_internal_elevator_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.elevator_id_;
}
inline void SetElevatorStatusRequest::_internal_set_elevator_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elevator_id_ = value;
}

// .smart_pkg_delivery.Elevator.Status elevator_status = 2;
inline bool SetElevatorStatusRequest::has_elevator_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.elevator_status_ != nullptr);
  return value;
}
inline void SetElevatorStatusRequest::clear_elevator_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.elevator_status_ != nullptr) _impl_.elevator_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::smart_pkg_delivery::Elevator_Status& SetElevatorStatusRequest::_internal_elevator_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::smart_pkg_delivery::Elevator_Status* p = _impl_.elevator_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::smart_pkg_delivery::Elevator_Status&>(::smart_pkg_delivery::_Elevator_Status_default_instance_);
}
inline const ::smart_pkg_delivery::Elevator_Status& SetElevatorStatusRequest::elevator_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.SetElevatorStatusRequest.elevator_status)
  return _internal_elevator_status();
}
inline void SetElevatorStatusRequest::unsafe_arena_set_allocated_elevator_status(::smart_pkg_delivery::Elevator_Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.elevator_status_);
  }
  _impl_.elevator_status_ = reinterpret_cast<::smart_pkg_delivery::Elevator_Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.SetElevatorStatusRequest.elevator_status)
}
inline ::smart_pkg_delivery::Elevator_Status* SetElevatorStatusRequest::release_elevator_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::Elevator_Status* released = _impl_.elevator_status_;
  _impl_.elevator_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::smart_pkg_delivery::Elevator_Status* SetElevatorStatusRequest::unsafe_arena_release_elevator_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.SetElevatorStatusRequest.elevator_status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::Elevator_Status* temp = _impl_.elevator_status_;
  _impl_.elevator_status_ = nullptr;
  return temp;
}
inline ::smart_pkg_delivery::Elevator_Status* SetElevatorStatusRequest::_internal_mutable_elevator_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.elevator_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::Elevator_Status>(GetArena());
    _impl_.elevator_status_ = reinterpret_cast<::smart_pkg_delivery::Elevator_Status*>(p);
  }
  return _impl_.elevator_status_;
}
inline ::smart_pkg_delivery::Elevator_Status* SetElevatorStatusRequest::mutable_elevator_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::smart_pkg_delivery::Elevator_Status* _msg = _internal_mutable_elevator_status();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.SetElevatorStatusRequest.elevator_status)
  return _msg;
}
inline void SetElevatorStatusRequest::set_allocated_elevator_status(::smart_pkg_delivery::Elevator_Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.elevator_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.elevator_status_ = reinterpret_cast<::smart_pkg_delivery::Elevator_Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.SetElevatorStatusRequest.elevator_status)
}

// -------------------------------------------------------------------

// SetElevatorStatusResponse

// -------------------------------------------------------------------

// PkgArrivalEvent

// .smart_pkg_delivery.AptAddress address = 1;
inline bool PkgArrivalEvent::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.address_ != nullptr);
  return value;
}
inline void PkgArrivalEvent::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.address_ != nullptr) _impl_.address_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::smart_pkg_delivery::AptAddress& PkgArrivalEvent::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::smart_pkg_delivery::AptAddress* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::smart_pkg_delivery::AptAddress&>(::smart_pkg_delivery::_AptAddress_default_instance_);
}
inline const ::smart_pkg_delivery::AptAddress& PkgArrivalEvent::address() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.PkgArrivalEvent.address)
  return _internal_address();
}
inline void PkgArrivalEvent::unsafe_arena_set_allocated_address(::smart_pkg_delivery::AptAddress* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.PkgArrivalEvent.address)
}
inline ::smart_pkg_delivery::AptAddress* PkgArrivalEvent::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::AptAddress* released = _impl_.address_;
  _impl_.address_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::smart_pkg_delivery::AptAddress* PkgArrivalEvent::unsafe_arena_release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.PkgArrivalEvent.address)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::AptAddress* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::smart_pkg_delivery::AptAddress* PkgArrivalEvent::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.address_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::AptAddress>(GetArena());
    _impl_.address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(p);
  }
  return _impl_.address_;
}
inline ::smart_pkg_delivery::AptAddress* PkgArrivalEvent::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::smart_pkg_delivery::AptAddress* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.PkgArrivalEvent.address)
  return _msg;
}
inline void PkgArrivalEvent::set_allocated_address(::smart_pkg_delivery::AptAddress* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(value);
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.PkgArrivalEvent.address)
}

// -------------------------------------------------------------------

// ElevatorStatusEvent

// uint32 elevator_id = 1;
inline bool ElevatorStatusEvent::has_elevator_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ElevatorStatusEvent::clear_elevator_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elevator_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ElevatorStatusEvent::elevator_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.ElevatorStatusEvent.elevator_id)
  return _internal_elevator_id();
}
inline void ElevatorStatusEvent::set_elevator_id(::uint32_t value) {
  _internal_set_elevator_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.ElevatorStatusEvent.elevator_id)
}
inline ::uint32_t ElevatorStatusEvent::_internal_elevator_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.elevator_id_;
}
inline void ElevatorStatusEvent::_internal_set_elevator_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elevator_id_ = value;
}

// .smart_pkg_delivery.Elevator.Status elevator_status = 2;
inline bool ElevatorStatusEvent::has_elevator_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.elevator_status_ != nullptr);
  return value;
}
inline void ElevatorStatusEvent::clear_elevator_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.elevator_status_ != nullptr) _impl_.elevator_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::smart_pkg_delivery::Elevator_Status& ElevatorStatusEvent::_internal_elevator_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::smart_pkg_delivery::Elevator_Status* p = _impl_.elevator_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::smart_pkg_delivery::Elevator_Status&>(::smart_pkg_delivery::_Elevator_Status_default_instance_);
}
inline const ::smart_pkg_delivery::Elevator_Status& ElevatorStatusEvent::elevator_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.ElevatorStatusEvent.elevator_status)
  return _internal_elevator_status();
}
inline void ElevatorStatusEvent::unsafe_arena_set_allocated_elevator_status(::smart_pkg_delivery::Elevator_Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.elevator_status_);
  }
  _impl_.elevator_status_ = reinterpret_cast<::smart_pkg_delivery::Elevator_Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.ElevatorStatusEvent.elevator_status)
}
inline ::smart_pkg_delivery::Elevator_Status* ElevatorStatusEvent::release_elevator_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::Elevator_Status* released = _impl_.elevator_status_;
  _impl_.elevator_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::smart_pkg_delivery::Elevator_Status* ElevatorStatusEvent::unsafe_arena_release_elevator_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.ElevatorStatusEvent.elevator_status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::Elevator_Status* temp = _impl_.elevator_status_;
  _impl_.elevator_status_ = nullptr;
  return temp;
}
inline ::smart_pkg_delivery::Elevator_Status* ElevatorStatusEvent::_internal_mutable_elevator_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.elevator_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::Elevator_Status>(GetArena());
    _impl_.elevator_status_ = reinterpret_cast<::smart_pkg_delivery::Elevator_Status*>(p);
  }
  return _impl_.elevator_status_;
}
inline ::smart_pkg_delivery::Elevator_Status* ElevatorStatusEvent::mutable_elevator_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::smart_pkg_delivery::Elevator_Status* _msg = _internal_mutable_elevator_status();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.ElevatorStatusEvent.elevator_status)
  return _msg;
}
inline void ElevatorStatusEvent::set_allocated_elevator_status(::smart_pkg_delivery::Elevator_Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.elevator_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.elevator_status_ = reinterpret_cast<::smart_pkg_delivery::Elevator_Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.ElevatorStatusEvent.elevator_status)
}

// -------------------------------------------------------------------

// DeliveryStatusEvent

// uint32 delivery_robot_id = 1;
inline bool DeliveryStatusEvent::has_delivery_robot_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DeliveryStatusEvent::clear_delivery_robot_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delivery_robot_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t DeliveryStatusEvent::delivery_robot_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.DeliveryStatusEvent.delivery_robot_id)
  return _internal_delivery_robot_id();
}
inline void DeliveryStatusEvent::set_delivery_robot_id(::uint32_t value) {
  _internal_set_delivery_robot_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.DeliveryStatusEvent.delivery_robot_id)
}
inline ::uint32_t DeliveryStatusEvent::_internal_delivery_robot_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delivery_robot_id_;
}
inline void DeliveryStatusEvent::_internal_set_delivery_robot_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delivery_robot_id_ = value;
}

// .smart_pkg_delivery.DeliveryRobot.DeliveryStatus delivery_status = 2;
inline bool DeliveryStatusEvent::has_delivery_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DeliveryStatusEvent::clear_delivery_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delivery_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::smart_pkg_delivery::DeliveryRobot_DeliveryStatus DeliveryStatusEvent::delivery_status() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.DeliveryStatusEvent.delivery_status)
  return _internal_delivery_status();
}
inline void DeliveryStatusEvent::set_delivery_status(::smart_pkg_delivery::DeliveryRobot_DeliveryStatus value) {
  _internal_set_delivery_status(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.DeliveryStatusEvent.delivery_status)
}
inline ::smart_pkg_delivery::DeliveryRobot_DeliveryStatus DeliveryStatusEvent::_internal_delivery_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::smart_pkg_delivery::DeliveryRobot_DeliveryStatus>(_impl_.delivery_status_);
}
inline void DeliveryStatusEvent::_internal_set_delivery_status(::smart_pkg_delivery::DeliveryRobot_DeliveryStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delivery_status_ = value;
}

// -------------------------------------------------------------------

// Elevator_Status

// uint32 current_floor = 1;
inline bool Elevator_Status::has_current_floor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Elevator_Status::clear_current_floor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_floor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Elevator_Status::current_floor() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Elevator.Status.current_floor)
  return _internal_current_floor();
}
inline void Elevator_Status::set_current_floor(::uint32_t value) {
  _internal_set_current_floor(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.Elevator.Status.current_floor)
}
inline ::uint32_t Elevator_Status::_internal_current_floor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_floor_;
}
inline void Elevator_Status::_internal_set_current_floor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_floor_ = value;
}

// .smart_pkg_delivery.Elevator.DoorOpenStatus door_open_status = 2;
inline bool Elevator_Status::has_door_open_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Elevator_Status::clear_door_open_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.door_open_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::smart_pkg_delivery::Elevator_DoorOpenStatus Elevator_Status::door_open_status() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Elevator.Status.door_open_status)
  return _internal_door_open_status();
}
inline void Elevator_Status::set_door_open_status(::smart_pkg_delivery::Elevator_DoorOpenStatus value) {
  _internal_set_door_open_status(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.Elevator.Status.door_open_status)
}
inline ::smart_pkg_delivery::Elevator_DoorOpenStatus Elevator_Status::_internal_door_open_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::smart_pkg_delivery::Elevator_DoorOpenStatus>(_impl_.door_open_status_);
}
inline void Elevator_Status::_internal_set_door_open_status(::smart_pkg_delivery::Elevator_DoorOpenStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.door_open_status_ = value;
}

// -------------------------------------------------------------------

// Elevator

// uint32 id = 1;
inline bool Elevator::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Elevator::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Elevator::id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Elevator.id)
  return _internal_id();
}
inline void Elevator::set_id(::uint32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.Elevator.id)
}
inline ::uint32_t Elevator::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Elevator::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .smart_pkg_delivery.Elevator.Status status = 2;
inline bool Elevator::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void Elevator::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::smart_pkg_delivery::Elevator_Status& Elevator::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::smart_pkg_delivery::Elevator_Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::smart_pkg_delivery::Elevator_Status&>(::smart_pkg_delivery::_Elevator_Status_default_instance_);
}
inline const ::smart_pkg_delivery::Elevator_Status& Elevator::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Elevator.status)
  return _internal_status();
}
inline void Elevator::unsafe_arena_set_allocated_status(::smart_pkg_delivery::Elevator_Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::smart_pkg_delivery::Elevator_Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Elevator.status)
}
inline ::smart_pkg_delivery::Elevator_Status* Elevator::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::Elevator_Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::smart_pkg_delivery::Elevator_Status* Elevator::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Elevator.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::Elevator_Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::smart_pkg_delivery::Elevator_Status* Elevator::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::Elevator_Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::smart_pkg_delivery::Elevator_Status*>(p);
  }
  return _impl_.status_;
}
inline ::smart_pkg_delivery::Elevator_Status* Elevator::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::smart_pkg_delivery::Elevator_Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Elevator.status)
  return _msg;
}
inline void Elevator::set_allocated_status(::smart_pkg_delivery::Elevator_Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::smart_pkg_delivery::Elevator_Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.Elevator.status)
}

// -------------------------------------------------------------------

// DeliveryRobot

// uint32 id = 1;
inline bool DeliveryRobot::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DeliveryRobot::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t DeliveryRobot::id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.DeliveryRobot.id)
  return _internal_id();
}
inline void DeliveryRobot::set_id(::uint32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.DeliveryRobot.id)
}
inline ::uint32_t DeliveryRobot::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void DeliveryRobot::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .smart_pkg_delivery.DeliveryRobot.DeliveryStatus delivery_status = 3;
inline bool DeliveryRobot::has_delivery_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DeliveryRobot::clear_delivery_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delivery_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::smart_pkg_delivery::DeliveryRobot_DeliveryStatus DeliveryRobot::delivery_status() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.DeliveryRobot.delivery_status)
  return _internal_delivery_status();
}
inline void DeliveryRobot::set_delivery_status(::smart_pkg_delivery::DeliveryRobot_DeliveryStatus value) {
  _internal_set_delivery_status(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.DeliveryRobot.delivery_status)
}
inline ::smart_pkg_delivery::DeliveryRobot_DeliveryStatus DeliveryRobot::_internal_delivery_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::smart_pkg_delivery::DeliveryRobot_DeliveryStatus>(_impl_.delivery_status_);
}
inline void DeliveryRobot::_internal_set_delivery_status(::smart_pkg_delivery::DeliveryRobot_DeliveryStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delivery_status_ = value;
}

// -------------------------------------------------------------------

// PkgRoom_Locker

// uint32 locker_id = 1;
inline bool PkgRoom_Locker::has_locker_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PkgRoom_Locker::clear_locker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locker_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t PkgRoom_Locker::locker_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.PkgRoom.Locker.locker_id)
  return _internal_locker_id();
}
inline void PkgRoom_Locker::set_locker_id(::uint32_t value) {
  _internal_set_locker_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.PkgRoom.Locker.locker_id)
}
inline ::uint32_t PkgRoom_Locker::_internal_locker_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.locker_id_;
}
inline void PkgRoom_Locker::_internal_set_locker_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locker_id_ = value;
}

// string access_code = 2;
inline bool PkgRoom_Locker::has_access_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PkgRoom_Locker::clear_access_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PkgRoom_Locker::access_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.PkgRoom.Locker.access_code)
  return _internal_access_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PkgRoom_Locker::set_access_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.PkgRoom.Locker.access_code)
}
inline std::string* PkgRoom_Locker::mutable_access_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_access_code();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.PkgRoom.Locker.access_code)
  return _s;
}
inline const std::string& PkgRoom_Locker::_internal_access_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.access_code_.Get();
}
inline void PkgRoom_Locker::_internal_set_access_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_code_.Set(value, GetArena());
}
inline std::string* PkgRoom_Locker::_internal_mutable_access_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.access_code_.Mutable( GetArena());
}
inline std::string* PkgRoom_Locker::release_access_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.PkgRoom.Locker.access_code)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.access_code_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.access_code_.Set("", GetArena());
  }
  return released;
}
inline void PkgRoom_Locker::set_allocated_access_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.access_code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.access_code_.IsDefault()) {
    _impl_.access_code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.PkgRoom.Locker.access_code)
}

// uint32 pkg_id = 3;
inline bool PkgRoom_Locker::has_pkg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PkgRoom_Locker::clear_pkg_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pkg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t PkgRoom_Locker::pkg_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.PkgRoom.Locker.pkg_id)
  return _internal_pkg_id();
}
inline void PkgRoom_Locker::set_pkg_id(::uint32_t value) {
  _internal_set_pkg_id(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.PkgRoom.Locker.pkg_id)
}
inline ::uint32_t PkgRoom_Locker::_internal_pkg_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pkg_id_;
}
inline void PkgRoom_Locker::_internal_set_pkg_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pkg_id_ = value;
}

// -------------------------------------------------------------------

// PkgRoom

// uint32 id = 1;
inline bool PkgRoom::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PkgRoom::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t PkgRoom::id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.PkgRoom.id)
  return _internal_id();
}
inline void PkgRoom::set_id(::uint32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.PkgRoom.id)
}
inline ::uint32_t PkgRoom::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void PkgRoom::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// repeated .smart_pkg_delivery.PkgRoom.Locker lockers = 2;
inline int PkgRoom::_internal_lockers_size() const {
  return _internal_lockers().size();
}
inline int PkgRoom::lockers_size() const {
  return _internal_lockers_size();
}
inline void PkgRoom::clear_lockers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lockers_.Clear();
}
inline ::smart_pkg_delivery::PkgRoom_Locker* PkgRoom::mutable_lockers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.PkgRoom.lockers)
  return _internal_mutable_lockers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::PkgRoom_Locker>* PkgRoom::mutable_lockers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:smart_pkg_delivery.PkgRoom.lockers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_lockers();
}
inline const ::smart_pkg_delivery::PkgRoom_Locker& PkgRoom::lockers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.PkgRoom.lockers)
  return _internal_lockers().Get(index);
}
inline ::smart_pkg_delivery::PkgRoom_Locker* PkgRoom::add_lockers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::smart_pkg_delivery::PkgRoom_Locker* _add = _internal_mutable_lockers()->Add();
  // @@protoc_insertion_point(field_add:smart_pkg_delivery.PkgRoom.lockers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::PkgRoom_Locker>& PkgRoom::lockers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:smart_pkg_delivery.PkgRoom.lockers)
  return _internal_lockers();
}
inline const ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::PkgRoom_Locker>&
PkgRoom::_internal_lockers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lockers_;
}
inline ::google::protobuf::RepeatedPtrField<::smart_pkg_delivery::PkgRoom_Locker>*
PkgRoom::_internal_mutable_lockers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.lockers_;
}

// -------------------------------------------------------------------

// User

// uint32 id = 1;
inline bool User::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void User::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t User::id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.User.id)
  return _internal_id();
}
inline void User::set_id(::uint32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.User.id)
}
inline ::uint32_t User::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void User::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .smart_pkg_delivery.AptAddress address = 2;
inline bool User::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.address_ != nullptr);
  return value;
}
inline void User::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.address_ != nullptr) _impl_.address_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::smart_pkg_delivery::AptAddress& User::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::smart_pkg_delivery::AptAddress* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::smart_pkg_delivery::AptAddress&>(::smart_pkg_delivery::_AptAddress_default_instance_);
}
inline const ::smart_pkg_delivery::AptAddress& User::address() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.User.address)
  return _internal_address();
}
inline void User::unsafe_arena_set_allocated_address(::smart_pkg_delivery::AptAddress* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.User.address)
}
inline ::smart_pkg_delivery::AptAddress* User::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::AptAddress* released = _impl_.address_;
  _impl_.address_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::smart_pkg_delivery::AptAddress* User::unsafe_arena_release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.User.address)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::smart_pkg_delivery::AptAddress* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::smart_pkg_delivery::AptAddress* User::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.address_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::AptAddress>(GetArena());
    _impl_.address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(p);
  }
  return _impl_.address_;
}
inline ::smart_pkg_delivery::AptAddress* User::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::smart_pkg_delivery::AptAddress* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.User.address)
  return _msg;
}
inline void User::set_allocated_address(::smart_pkg_delivery::AptAddress* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(value);
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.User.address)
}

// -------------------------------------------------------------------

// Pkg

// uint32 id = 1;
inline bool Pkg::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Pkg::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t Pkg::id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Pkg.id)
  return _internal_id();
}
inline void Pkg::set_id(::uint32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.Pkg.id)
}
inline ::uint32_t Pkg::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Pkg::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .smart_pkg_delivery.AptAddress address = 2;
inline bool Pkg::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.address_ != nullptr);
  return value;
}
inline void Pkg::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.address_ != nullptr) _impl_.address_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::smart_pkg_delivery::AptAddress& Pkg::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::smart_pkg_delivery::AptAddress* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::smart_pkg_delivery::AptAddress&>(::smart_pkg_delivery::_AptAddress_default_instance_);
}
inline const ::smart_pkg_delivery::AptAddress& Pkg::address() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Pkg.address)
  return _internal_address();
}
inline void Pkg::unsafe_arena_set_allocated_address(::smart_pkg_delivery::AptAddress* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:smart_pkg_delivery.Pkg.address)
}
inline ::smart_pkg_delivery::AptAddress* Pkg::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::smart_pkg_delivery::AptAddress* released = _impl_.address_;
  _impl_.address_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::smart_pkg_delivery::AptAddress* Pkg::unsafe_arena_release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Pkg.address)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::smart_pkg_delivery::AptAddress* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::smart_pkg_delivery::AptAddress* Pkg::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.address_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::smart_pkg_delivery::AptAddress>(GetArena());
    _impl_.address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(p);
  }
  return _impl_.address_;
}
inline ::smart_pkg_delivery::AptAddress* Pkg::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::smart_pkg_delivery::AptAddress* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Pkg.address)
  return _msg;
}
inline void Pkg::set_allocated_address(::smart_pkg_delivery::AptAddress* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.address_ = reinterpret_cast<::smart_pkg_delivery::AptAddress*>(value);
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.Pkg.address)
}

// uint32 sender_id = 3;
inline bool Pkg::has_sender_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Pkg::clear_sender_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t Pkg::sender_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Pkg.sender_id)
  return _internal_sender_id();
}
inline void Pkg::set_sender_id(::uint32_t value) {
  _internal_set_sender_id(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.Pkg.sender_id)
}
inline ::uint32_t Pkg::_internal_sender_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sender_id_;
}
inline void Pkg::_internal_set_sender_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_id_ = value;
}

// uint32 receiver_id = 4;
inline bool Pkg::has_receiver_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Pkg::clear_receiver_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.receiver_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t Pkg::receiver_id() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Pkg.receiver_id)
  return _internal_receiver_id();
}
inline void Pkg::set_receiver_id(::uint32_t value) {
  _internal_set_receiver_id(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.Pkg.receiver_id)
}
inline ::uint32_t Pkg::_internal_receiver_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.receiver_id_;
}
inline void Pkg::_internal_set_receiver_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.receiver_id_ = value;
}

// bytes photo_bytes = 5;
inline bool Pkg::has_photo_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Pkg::clear_photo_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.photo_bytes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Pkg::photo_bytes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.Pkg.photo_bytes)
  return _internal_photo_bytes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pkg::set_photo_bytes(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.photo_bytes_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.Pkg.photo_bytes)
}
inline std::string* Pkg::mutable_photo_bytes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_photo_bytes();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.Pkg.photo_bytes)
  return _s;
}
inline const std::string& Pkg::_internal_photo_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.photo_bytes_.Get();
}
inline void Pkg::_internal_set_photo_bytes(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.photo_bytes_.Set(value, GetArena());
}
inline std::string* Pkg::_internal_mutable_photo_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.photo_bytes_.Mutable( GetArena());
}
inline std::string* Pkg::release_photo_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.Pkg.photo_bytes)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.photo_bytes_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.photo_bytes_.Set("", GetArena());
  }
  return released;
}
inline void Pkg::set_allocated_photo_bytes(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.photo_bytes_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.photo_bytes_.IsDefault()) {
    _impl_.photo_bytes_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.Pkg.photo_bytes)
}

// -------------------------------------------------------------------

// AptAddress

// string apt_complex = 1;
inline bool AptAddress::has_apt_complex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AptAddress::clear_apt_complex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apt_complex_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AptAddress::apt_complex() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.AptAddress.apt_complex)
  return _internal_apt_complex();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AptAddress::set_apt_complex(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.apt_complex_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.AptAddress.apt_complex)
}
inline std::string* AptAddress::mutable_apt_complex() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_apt_complex();
  // @@protoc_insertion_point(field_mutable:smart_pkg_delivery.AptAddress.apt_complex)
  return _s;
}
inline const std::string& AptAddress::_internal_apt_complex() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.apt_complex_.Get();
}
inline void AptAddress::_internal_set_apt_complex(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.apt_complex_.Set(value, GetArena());
}
inline std::string* AptAddress::_internal_mutable_apt_complex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.apt_complex_.Mutable( GetArena());
}
inline std::string* AptAddress::release_apt_complex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:smart_pkg_delivery.AptAddress.apt_complex)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.apt_complex_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.apt_complex_.Set("", GetArena());
  }
  return released;
}
inline void AptAddress::set_allocated_apt_complex(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.apt_complex_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.apt_complex_.IsDefault()) {
    _impl_.apt_complex_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:smart_pkg_delivery.AptAddress.apt_complex)
}

// uint32 building_num = 2;
inline bool AptAddress::has_building_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AptAddress::clear_building_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.building_num_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AptAddress::building_num() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.AptAddress.building_num)
  return _internal_building_num();
}
inline void AptAddress::set_building_num(::uint32_t value) {
  _internal_set_building_num(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.AptAddress.building_num)
}
inline ::uint32_t AptAddress::_internal_building_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.building_num_;
}
inline void AptAddress::_internal_set_building_num(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.building_num_ = value;
}

// uint32 unit_num = 3;
inline bool AptAddress::has_unit_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AptAddress::clear_unit_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unit_num_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t AptAddress::unit_num() const {
  // @@protoc_insertion_point(field_get:smart_pkg_delivery.AptAddress.unit_num)
  return _internal_unit_num();
}
inline void AptAddress::set_unit_num(::uint32_t value) {
  _internal_set_unit_num(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:smart_pkg_delivery.AptAddress.unit_num)
}
inline ::uint32_t AptAddress::_internal_unit_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unit_num_;
}
inline void AptAddress::_internal_set_unit_num(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unit_num_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace smart_pkg_delivery


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::smart_pkg_delivery::AckStatus_StatusCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::smart_pkg_delivery::AckStatus_StatusCode>() {
  return ::smart_pkg_delivery::AckStatus_StatusCode_descriptor();
}
template <>
struct is_proto_enum<::smart_pkg_delivery::ExecutionStatus_StatusCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::smart_pkg_delivery::ExecutionStatus_StatusCode>() {
  return ::smart_pkg_delivery::ExecutionStatus_StatusCode_descriptor();
}
template <>
struct is_proto_enum<::smart_pkg_delivery::Elevator_DoorOpenStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::smart_pkg_delivery::Elevator_DoorOpenStatus>() {
  return ::smart_pkg_delivery::Elevator_DoorOpenStatus_descriptor();
}
template <>
struct is_proto_enum<::smart_pkg_delivery::DeliveryRobot_DeliveryStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::smart_pkg_delivery::DeliveryRobot_DeliveryStatus>() {
  return ::smart_pkg_delivery::DeliveryRobot_DeliveryStatus_descriptor();
}
template <>
struct is_proto_enum<::smart_pkg_delivery::NodeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::smart_pkg_delivery::NodeType>() {
  return ::smart_pkg_delivery::NodeType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // smart_5fpkg_5fdelivery_2eproto_2epb_2eh
